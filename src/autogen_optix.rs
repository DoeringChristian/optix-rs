/* automatically generated by rust-bindgen 0.65.1 */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OptixDeviceContext_t {
    _unused: [u8; 0],
}
#[doc = " Opaque type representing a device context"]
pub type OptixDeviceContext = *mut OptixDeviceContext_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OptixModule_t {
    _unused: [u8; 0],
}
#[doc = " Opaque type representing a module"]
pub type OptixModule = *mut OptixModule_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OptixProgramGroup_t {
    _unused: [u8; 0],
}
#[doc = " Opaque type representing a program group"]
pub type OptixProgramGroup = *mut OptixProgramGroup_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OptixPipeline_t {
    _unused: [u8; 0],
}
#[doc = " Opaque type representing a pipeline"]
pub type OptixPipeline = *mut OptixPipeline_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OptixDenoiser_t {
    _unused: [u8; 0],
}
#[doc = " Opaque type representing a denoiser instance"]
pub type OptixDenoiser = *mut OptixDenoiser_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OptixTask_t {
    _unused: [u8; 0],
}
#[doc = " Opaque type representing a work task"]
pub type OptixTask = *mut OptixTask_t;
#[doc = " Traversable handle"]
pub type OptixTraversableHandle = ::std::os::raw::c_ulonglong;
#[doc = " Visibility mask"]
pub type OptixVisibilityMask = ::std::os::raw::c_uint;
#[repr(u32)]
#[doc = " Result codes returned from API functions\n\n All host side API functions return OptixResult with the exception of optixGetErrorName\n and optixGetErrorString.  When successful OPTIX_SUCCESS is returned.  All return codes\n except for OPTIX_SUCCESS should be assumed to be errors as opposed to a warning.\n\n \\see #optixGetErrorName(), #optixGetErrorString()"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum OptixResult {
    OPTIX_SUCCESS = 0,
    OPTIX_ERROR_INVALID_VALUE = 7001,
    OPTIX_ERROR_HOST_OUT_OF_MEMORY = 7002,
    OPTIX_ERROR_INVALID_OPERATION = 7003,
    OPTIX_ERROR_FILE_IO_ERROR = 7004,
    OPTIX_ERROR_INVALID_FILE_FORMAT = 7005,
    OPTIX_ERROR_DISK_CACHE_INVALID_PATH = 7010,
    OPTIX_ERROR_DISK_CACHE_PERMISSION_ERROR = 7011,
    OPTIX_ERROR_DISK_CACHE_DATABASE_ERROR = 7012,
    OPTIX_ERROR_DISK_CACHE_INVALID_DATA = 7013,
    OPTIX_ERROR_LAUNCH_FAILURE = 7050,
    OPTIX_ERROR_INVALID_DEVICE_CONTEXT = 7051,
    OPTIX_ERROR_CUDA_NOT_INITIALIZED = 7052,
    OPTIX_ERROR_VALIDATION_FAILURE = 7053,
    OPTIX_ERROR_INVALID_PTX = 7200,
    OPTIX_ERROR_INVALID_LAUNCH_PARAMETER = 7201,
    OPTIX_ERROR_INVALID_PAYLOAD_ACCESS = 7202,
    OPTIX_ERROR_INVALID_ATTRIBUTE_ACCESS = 7203,
    OPTIX_ERROR_INVALID_FUNCTION_USE = 7204,
    OPTIX_ERROR_INVALID_FUNCTION_ARGUMENTS = 7205,
    OPTIX_ERROR_PIPELINE_OUT_OF_CONSTANT_MEMORY = 7250,
    OPTIX_ERROR_PIPELINE_LINK_ERROR = 7251,
    OPTIX_ERROR_ILLEGAL_DURING_TASK_EXECUTE = 7270,
    OPTIX_ERROR_INTERNAL_COMPILER_ERROR = 7299,
    OPTIX_ERROR_DENOISER_MODEL_NOT_SET = 7300,
    OPTIX_ERROR_DENOISER_NOT_INITIALIZED = 7301,
    OPTIX_ERROR_ACCEL_NOT_COMPATIBLE = 7400,
    OPTIX_ERROR_PAYLOAD_TYPE_MISMATCH = 7500,
    OPTIX_ERROR_PAYLOAD_TYPE_RESOLUTION_FAILED = 7501,
    OPTIX_ERROR_PAYLOAD_TYPE_ID_INVALID = 7502,
    OPTIX_ERROR_NOT_SUPPORTED = 7800,
    OPTIX_ERROR_UNSUPPORTED_ABI_VERSION = 7801,
    OPTIX_ERROR_FUNCTION_TABLE_SIZE_MISMATCH = 7802,
    OPTIX_ERROR_INVALID_ENTRY_FUNCTION_OPTIONS = 7803,
    OPTIX_ERROR_LIBRARY_NOT_FOUND = 7804,
    OPTIX_ERROR_ENTRY_SYMBOL_NOT_FOUND = 7805,
    OPTIX_ERROR_LIBRARY_UNLOAD_FAILURE = 7806,
    OPTIX_ERROR_DEVICE_OUT_OF_MEMORY = 7807,
    OPTIX_ERROR_CUDA_ERROR = 7900,
    OPTIX_ERROR_INTERNAL_ERROR = 7990,
    OPTIX_ERROR_UNKNOWN = 7999,
}
#[repr(u32)]
#[doc = " Parameters used for #optixDeviceContextGetProperty()\n\n \\see #optixDeviceContextGetProperty()"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum OptixDeviceProperty {
    #[doc = " Maximum value for OptixPipelineLinkOptions::maxTraceDepth. sizeof( unsigned int )"]
    OPTIX_DEVICE_PROPERTY_LIMIT_MAX_TRACE_DEPTH = 8193,
    #[doc = " Maximum value to pass into optixPipelineSetStackSize for parameter\n maxTraversableGraphDepth.v sizeof( unsigned int )"]
    OPTIX_DEVICE_PROPERTY_LIMIT_MAX_TRAVERSABLE_GRAPH_DEPTH = 8194,
    #[doc = " The maximum number of primitives (over all build inputs) as input to a single\n Geometry Acceleration Structure (GAS). sizeof( unsigned int )"]
    OPTIX_DEVICE_PROPERTY_LIMIT_MAX_PRIMITIVES_PER_GAS = 8195,
    #[doc = " The maximum number of instances (over all build inputs) as input to a single\n Instance Acceleration Structure (IAS). sizeof( unsigned int )"]
    OPTIX_DEVICE_PROPERTY_LIMIT_MAX_INSTANCES_PER_IAS = 8196,
    #[doc = " The RT core version supported by the device (0 for no support, 10 for version\n 1.0). sizeof( unsigned int )"]
    OPTIX_DEVICE_PROPERTY_RTCORE_VERSION = 8197,
    #[doc = " The maximum value for #OptixInstance::instanceId. sizeof( unsigned int )"]
    OPTIX_DEVICE_PROPERTY_LIMIT_MAX_INSTANCE_ID = 8198,
    #[doc = " The number of bits available for the #OptixInstance::visibilityMask.\n Higher bits must be set to zero. sizeof( unsigned int )"]
    OPTIX_DEVICE_PROPERTY_LIMIT_NUM_BITS_INSTANCE_VISIBILITY_MASK = 8199,
    #[doc = " The maximum number of instances that can be added to a single Instance\n Acceleration Structure (IAS). sizeof( unsigned int )"]
    OPTIX_DEVICE_PROPERTY_LIMIT_MAX_SBT_RECORDS_PER_GAS = 8200,
    #[doc = " The maximum value for #OptixInstance::sbtOffset. sizeof( unsigned int )"]
    OPTIX_DEVICE_PROPERTY_LIMIT_MAX_SBT_OFFSET = 8201,
}
#[doc = " Type of the callback function used for log messages.\n\n \\param[in] level      The log level indicates the severity of the message. See below for\n                       possible values.\n \\param[in] tag        A terse message category description (e.g., 'SCENE STAT').\n \\param[in] message    Null terminated log message (without newline at the end).\n \\param[in] cbdata     Callback data that was provided with the callback pointer.\n\n It is the users responsibility to ensure thread safety within this function.\n\n The following log levels are defined.\n\n   0   disable   Setting the callback level will disable all messages.  The callback\n                 function will not be called in this case.\n   1   fatal     A non-recoverable error. The context and/or OptiX itself might no longer\n                 be in a usable state.\n   2   error     A recoverable error, e.g., when passing invalid call parameters.\n   3   warning   Hints that OptiX might not behave exactly as requested by the user or\n                 may perform slower than expected.\n   4   print     Status or progress messages.\n\n Higher levels might occur.\n\n \\see #optixDeviceContextSetLogCallback(), #OptixDeviceContextOptions"]
pub type OptixLogCallback = ::std::option::Option<
    unsafe extern "C" fn(
        level: ::std::os::raw::c_uint,
        tag: *const ::std::os::raw::c_char,
        message: *const ::std::os::raw::c_char,
        cbdata: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(u32)]
#[doc = " Validation mode settings.\n\n When enabled, certain device code utilities will be enabled to provide as good debug and\n error checking facilities as possible.\n\n\n \\see #optixDeviceContextCreate()"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum OptixDeviceContextValidationMode {
    OPTIX_DEVICE_CONTEXT_VALIDATION_MODE_OFF = 0,
    OPTIX_DEVICE_CONTEXT_VALIDATION_MODE_ALL = 4294967295,
}
#[doc = " Parameters used for #optixDeviceContextCreate()\n\n \\see #optixDeviceContextCreate()"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct OptixDeviceContextOptions {
    #[doc = " Function pointer used when OptiX wishes to generate messages"]
    pub logCallbackFunction: OptixLogCallback,
    #[doc = " Pointer stored and passed to logCallbackFunction when a message is generated"]
    pub logCallbackData: *mut ::std::os::raw::c_void,
    #[doc = " Maximum callback level to generate message for (see #OptixLogCallback)"]
    pub logCallbackLevel: ::std::os::raw::c_int,
    #[doc = " Validation mode of context."]
    pub validationMode: OptixDeviceContextValidationMode,
}
#[test]
fn bindgen_test_layout_OptixDeviceContextOptions() {
    const UNINIT: ::std::mem::MaybeUninit<OptixDeviceContextOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OptixDeviceContextOptions>(),
        24usize,
        concat!("Size of: ", stringify!(OptixDeviceContextOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<OptixDeviceContextOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(OptixDeviceContextOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).logCallbackFunction) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixDeviceContextOptions),
            "::",
            stringify!(logCallbackFunction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).logCallbackData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixDeviceContextOptions),
            "::",
            stringify!(logCallbackData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).logCallbackLevel) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixDeviceContextOptions),
            "::",
            stringify!(logCallbackLevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).validationMode) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixDeviceContextOptions),
            "::",
            stringify!(validationMode)
        )
    );
}
impl Default for OptixDeviceContextOptions {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[doc = " Flags used by #OptixBuildInputTriangleArray::flags\n and #OptixBuildInput::flag\n and #OptixBuildInputCustomPrimitiveArray::flags"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum OptixGeometryFlags {
    #[doc = " No flags set"]
    OPTIX_GEOMETRY_FLAG_NONE = 0,
    #[doc = " Disables the invocation of the anyhit program.\n Can be overridden by OPTIX_INSTANCE_FLAG_ENFORCE_ANYHIT and OPTIX_RAY_FLAG_ENFORCE_ANYHIT."]
    OPTIX_GEOMETRY_FLAG_DISABLE_ANYHIT = 1,
    #[doc = " If set, an intersection with the primitive will trigger one and only one\n invocation of the anyhit program.  Otherwise, the anyhit program may be invoked\n more than once."]
    OPTIX_GEOMETRY_FLAG_REQUIRE_SINGLE_ANYHIT_CALL = 2,
    #[doc = " Prevent triangles from getting culled due to their orientation.\n Effectively ignores ray flags\n OPTIX_RAY_FLAG_CULL_BACK_FACING_TRIANGLES and OPTIX_RAY_FLAG_CULL_FRONT_FACING_TRIANGLES."]
    OPTIX_GEOMETRY_FLAG_DISABLE_TRIANGLE_FACE_CULLING = 4,
}
#[repr(u32)]
#[doc = " Legacy type: A subset of the hit kinds for built-in primitive intersections.\n It is preferred to use optixGetPrimitiveType(), together with\n optixIsFrontFaceHit() or optixIsBackFaceHit().\n\n \\see #optixGetHitKind()"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum OptixHitKind {
    #[doc = " Ray hit the triangle on the front face"]
    OPTIX_HIT_KIND_TRIANGLE_FRONT_FACE = 254,
    #[doc = " Ray hit the triangle on the back face"]
    OPTIX_HIT_KIND_TRIANGLE_BACK_FACE = 255,
}
#[repr(u32)]
#[doc = " Format of indices used int #OptixBuildInputTriangleArray::indexFormat."]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum OptixIndicesFormat {
    #[doc = " No indices, this format must only be used in combination with triangle soups, i.e., numIndexTriplets must be zero"]
    OPTIX_INDICES_FORMAT_NONE = 0,
    #[doc = " Three shorts"]
    OPTIX_INDICES_FORMAT_UNSIGNED_SHORT3 = 8450,
    #[doc = " Three ints"]
    OPTIX_INDICES_FORMAT_UNSIGNED_INT3 = 8451,
}
#[repr(u32)]
#[doc = " Format of vertices used in #OptixBuildInputTriangleArray::vertexFormat."]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum OptixVertexFormat {
    #[doc = "< No vertices"]
    OPTIX_VERTEX_FORMAT_NONE = 0,
    #[doc = "< Vertices are represented by three floats"]
    OPTIX_VERTEX_FORMAT_FLOAT3 = 8481,
    #[doc = "< Vertices are represented by two floats"]
    OPTIX_VERTEX_FORMAT_FLOAT2 = 8482,
    #[doc = "< Vertices are represented by three halfs"]
    OPTIX_VERTEX_FORMAT_HALF3 = 8483,
    #[doc = "< Vertices are represented by two halfs"]
    OPTIX_VERTEX_FORMAT_HALF2 = 8484,
    OPTIX_VERTEX_FORMAT_SNORM16_3 = 8485,
    OPTIX_VERTEX_FORMAT_SNORM16_2 = 8486,
}
#[repr(u32)]
#[doc = " Format of transform used in #OptixBuildInputTriangleArray::transformFormat."]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum OptixTransformFormat {
    #[doc = "< no transform, default for zero initialization"]
    OPTIX_TRANSFORM_FORMAT_NONE = 0,
    #[doc = "< 3x4 row major affine matrix"]
    OPTIX_TRANSFORM_FORMAT_MATRIX_FLOAT12 = 8673,
}
#[doc = " Triangle inputs\n\n \\see #OptixBuildInput::triangleArray"]
#[repr(C)]
pub struct OptixBuildInputTriangleArray {
    #[doc = " Points to host array of device pointers, one per motion step. Host array size must match the number of\n motion keys as set in #OptixMotionOptions (or an array of size 1 if OptixMotionOptions::numKeys is set\n to 0 or 1). Each per motion key device pointer must point to an array of vertices of the\n triangles in the format as described by vertexFormat. The minimum alignment must match the natural\n alignment of the type as specified in the vertexFormat, i.e., for OPTIX_VERTEX_FORMAT_FLOATX 4-byte,\n for all others a 2-byte alignment. However, an 16-byte stride (and buffer alignment) is recommended for\n vertices of format OPTIX_VERTEX_FORMAT_FLOAT3 for GAS build performance."]
    pub vertexBuffers: *const CUdeviceptr,
    #[doc = " Number of vertices in each of buffer in OptixBuildInputTriangleArray::vertexBuffers."]
    pub numVertices: ::std::os::raw::c_uint,
    #[doc = " \\see #OptixVertexFormat"]
    pub vertexFormat: OptixVertexFormat,
    #[doc = " Stride between vertices. If set to zero, vertices are assumed to be tightly\n packed and stride is inferred from vertexFormat."]
    pub vertexStrideInBytes: ::std::os::raw::c_uint,
    #[doc = " Optional pointer to array of 16 or 32-bit int triplets, one triplet per triangle.\n The minimum alignment must match the natural alignment of the type as specified in the indexFormat, i.e.,\n for OPTIX_INDICES_FORMAT_UNSIGNED_INT3 4-byte and for OPTIX_INDICES_FORMAT_UNSIGNED_SHORT3 a 2-byte alignment."]
    pub indexBuffer: CUdeviceptr,
    #[doc = " Size of array in OptixBuildInputTriangleArray::indexBuffer. For build, needs to be zero if indexBuffer is \\c nullptr."]
    pub numIndexTriplets: ::std::os::raw::c_uint,
    #[doc = " \\see #OptixIndicesFormat"]
    pub indexFormat: OptixIndicesFormat,
    #[doc = " Stride between triplets of indices. If set to zero, indices are assumed to be tightly\n packed and stride is inferred from indexFormat."]
    pub indexStrideInBytes: ::std::os::raw::c_uint,
    #[doc = " Optional pointer to array of floats\n representing a 3x4 row major affine\n transformation matrix. This pointer must be a multiple of OPTIX_GEOMETRY_TRANSFORM_BYTE_ALIGNMENT"]
    pub preTransform: CUdeviceptr,
    #[doc = " Array of flags, to specify flags per sbt record,\n combinations of OptixGeometryFlags describing the\n primitive behavior, size must match numSbtRecords"]
    pub flags: *const ::std::os::raw::c_uint,
    #[doc = " Number of sbt records available to the sbt index offset override."]
    pub numSbtRecords: ::std::os::raw::c_uint,
    #[doc = " Device pointer to per-primitive local sbt index offset buffer. May be NULL.\n Every entry must be in range [0,numSbtRecords-1].\n Size needs to be the number of primitives."]
    pub sbtIndexOffsetBuffer: CUdeviceptr,
    #[doc = " Size of type of the sbt index offset. Needs to be 0, 1, 2 or 4 (8, 16 or 32 bit)."]
    pub sbtIndexOffsetSizeInBytes: ::std::os::raw::c_uint,
    #[doc = " Stride between the index offsets. If set to zero, the offsets are assumed to be tightly\n packed and the stride matches the size of the type (sbtIndexOffsetSizeInBytes)."]
    pub sbtIndexOffsetStrideInBytes: ::std::os::raw::c_uint,
    #[doc = " Primitive index bias, applied in optixGetPrimitiveIndex().\n Sum of primitiveIndexOffset and number of triangles must not overflow 32bits."]
    pub primitiveIndexOffset: ::std::os::raw::c_uint,
    #[doc = " \\see #OptixTransformFormat"]
    pub transformFormat: OptixTransformFormat,
}
#[test]
fn bindgen_test_layout_OptixBuildInputTriangleArray() {
    const UNINIT: ::std::mem::MaybeUninit<OptixBuildInputTriangleArray> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OptixBuildInputTriangleArray>(),
        96usize,
        concat!("Size of: ", stringify!(OptixBuildInputTriangleArray))
    );
    assert_eq!(
        ::std::mem::align_of::<OptixBuildInputTriangleArray>(),
        8usize,
        concat!("Alignment of ", stringify!(OptixBuildInputTriangleArray))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vertexBuffers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInputTriangleArray),
            "::",
            stringify!(vertexBuffers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numVertices) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInputTriangleArray),
            "::",
            stringify!(numVertices)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vertexFormat) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInputTriangleArray),
            "::",
            stringify!(vertexFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vertexStrideInBytes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInputTriangleArray),
            "::",
            stringify!(vertexStrideInBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).indexBuffer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInputTriangleArray),
            "::",
            stringify!(indexBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numIndexTriplets) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInputTriangleArray),
            "::",
            stringify!(numIndexTriplets)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).indexFormat) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInputTriangleArray),
            "::",
            stringify!(indexFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).indexStrideInBytes) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInputTriangleArray),
            "::",
            stringify!(indexStrideInBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).preTransform) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInputTriangleArray),
            "::",
            stringify!(preTransform)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInputTriangleArray),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numSbtRecords) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInputTriangleArray),
            "::",
            stringify!(numSbtRecords)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sbtIndexOffsetBuffer) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInputTriangleArray),
            "::",
            stringify!(sbtIndexOffsetBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sbtIndexOffsetSizeInBytes) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInputTriangleArray),
            "::",
            stringify!(sbtIndexOffsetSizeInBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sbtIndexOffsetStrideInBytes) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInputTriangleArray),
            "::",
            stringify!(sbtIndexOffsetStrideInBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).primitiveIndexOffset) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInputTriangleArray),
            "::",
            stringify!(primitiveIndexOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transformFormat) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInputTriangleArray),
            "::",
            stringify!(transformFormat)
        )
    );
}
impl Default for OptixBuildInputTriangleArray {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[doc = " Builtin primitive types\n"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum OptixPrimitiveType {
    #[doc = " Custom primitive."]
    OPTIX_PRIMITIVE_TYPE_CUSTOM = 9472,
    #[doc = " B-spline curve of degree 2 with circular cross-section."]
    OPTIX_PRIMITIVE_TYPE_ROUND_QUADRATIC_BSPLINE = 9473,
    #[doc = " B-spline curve of degree 3 with circular cross-section."]
    OPTIX_PRIMITIVE_TYPE_ROUND_CUBIC_BSPLINE = 9474,
    #[doc = " Piecewise linear curve with circular cross-section."]
    OPTIX_PRIMITIVE_TYPE_ROUND_LINEAR = 9475,
    #[doc = " CatmullRom curve with circular cross-section."]
    OPTIX_PRIMITIVE_TYPE_ROUND_CATMULLROM = 9476,
    #[doc = " CatmullRom curve with circular cross-section."]
    OPTIX_PRIMITIVE_TYPE_SPHERE = 9478,
    #[doc = " Triangle."]
    OPTIX_PRIMITIVE_TYPE_TRIANGLE = 9521,
}
#[repr(i32)]
#[doc = " Builtin flags may be bitwise combined.\n\n \\see #OptixPipelineCompileOptions::usesPrimitiveTypeFlags"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum OptixPrimitiveTypeFlags {
    #[doc = " Custom primitive."]
    OPTIX_PRIMITIVE_TYPE_FLAGS_CUSTOM = 1,
    #[doc = " B-spline curve of degree 2 with circular cross-section."]
    OPTIX_PRIMITIVE_TYPE_FLAGS_ROUND_QUADRATIC_BSPLINE = 2,
    #[doc = " B-spline curve of degree 3 with circular cross-section."]
    OPTIX_PRIMITIVE_TYPE_FLAGS_ROUND_CUBIC_BSPLINE = 4,
    #[doc = " Piecewise linear curve with circular cross-section."]
    OPTIX_PRIMITIVE_TYPE_FLAGS_ROUND_LINEAR = 8,
    #[doc = " CatmullRom curve with circular cross-section."]
    OPTIX_PRIMITIVE_TYPE_FLAGS_ROUND_CATMULLROM = 16,
    #[doc = " CatmullRom curve with circular cross-section."]
    OPTIX_PRIMITIVE_TYPE_FLAGS_SPHERE = 64,
    #[doc = " Triangle."]
    OPTIX_PRIMITIVE_TYPE_FLAGS_TRIANGLE = -2147483648,
}
#[repr(u32)]
#[doc = " Curve end cap types, for non-linear curves\n"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum OptixCurveEndcapFlags {
    #[doc = " Default end caps. Round end caps for linear, no end caps for quadratic/cubic."]
    OPTIX_CURVE_ENDCAP_DEFAULT = 0,
    #[doc = " Flat end caps at both ends of quadratic/cubic curve segments. Not valid for linear."]
    OPTIX_CURVE_ENDCAP_ON = 1,
}
#[doc = " Curve inputs\n\n A curve is a swept surface defined by a 3D spline curve and a varying width (radius). A curve (or \"strand\") of\n degree d (3=cubic, 2=quadratic, 1=linear) is represented by N > d vertices and N width values, and comprises N - d segments.\n Each segment is defined by d+1 consecutive vertices. Each curve may have a different number of vertices.\n\n OptiX describes the curve array as a list of curve segments. The primitive id is the segment number.\n It is the user's responsibility to maintain a mapping between curves and curve segments.\n Each index buffer entry i = indexBuffer[primid] specifies the start of a curve segment,\n represented by d+1 consecutive vertices in the vertex buffer,\n and d+1 consecutive widths in the width buffer. Width is interpolated the same\n way vertices are interpolated, that is, using the curve basis.\n\n Each curves build input has only one SBT record.\n To create curves with different materials in the same BVH, use multiple build inputs.\n\n \\see #OptixBuildInput::curveArray"]
#[repr(C)]
pub struct OptixBuildInputCurveArray {
    #[doc = " Curve degree and basis\n \\see #OptixPrimitiveType"]
    pub curveType: OptixPrimitiveType,
    #[doc = " Number of primitives. Each primitive is a polynomial curve segment."]
    pub numPrimitives: ::std::os::raw::c_uint,
    #[doc = " Pointer to host array of device pointers, one per motion step. Host array size must match number of\n motion keys as set in #OptixMotionOptions (or an array of size 1 if OptixMotionOptions::numKeys is set\n to 1). Each per-motion-key device pointer must point to an array of floats (the vertices of the\n curves)."]
    pub vertexBuffers: *const CUdeviceptr,
    #[doc = " Number of vertices in each buffer in vertexBuffers."]
    pub numVertices: ::std::os::raw::c_uint,
    #[doc = " Stride between vertices. If set to zero, vertices are assumed to be tightly\n packed and stride is sizeof( float3 )."]
    pub vertexStrideInBytes: ::std::os::raw::c_uint,
    #[doc = " Parallel to vertexBuffers: a device pointer per motion step, each with numVertices float values,\n specifying the curve width (radius) corresponding to each vertex."]
    pub widthBuffers: *const CUdeviceptr,
    #[doc = " Stride between widths. If set to zero, widths are assumed to be tightly\n packed and stride is sizeof( float )."]
    pub widthStrideInBytes: ::std::os::raw::c_uint,
    #[doc = " Reserved for future use."]
    pub normalBuffers: *const CUdeviceptr,
    #[doc = " Reserved for future use."]
    pub normalStrideInBytes: ::std::os::raw::c_uint,
    #[doc = " Device pointer to array of unsigned ints, one per curve segment.\n This buffer is required (unlike for OptixBuildInputTriangleArray).\n Each index is the start of degree+1 consecutive vertices in vertexBuffers,\n and corresponding widths in widthBuffers and normals in normalBuffers.\n These define a single segment. Size of array is numPrimitives."]
    pub indexBuffer: CUdeviceptr,
    #[doc = " Stride between indices. If set to zero, indices are assumed to be tightly\n packed and stride is sizeof( unsigned int )."]
    pub indexStrideInBytes: ::std::os::raw::c_uint,
    #[doc = " Combination of OptixGeometryFlags describing the\n primitive behavior."]
    pub flag: ::std::os::raw::c_uint,
    #[doc = " Primitive index bias, applied in optixGetPrimitiveIndex().\n Sum of primitiveIndexOffset and number of primitives must not overflow 32bits."]
    pub primitiveIndexOffset: ::std::os::raw::c_uint,
    #[doc = " End cap flags, see OptixCurveEndcapFlags"]
    pub endcapFlags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_OptixBuildInputCurveArray() {
    const UNINIT: ::std::mem::MaybeUninit<OptixBuildInputCurveArray> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OptixBuildInputCurveArray>(),
        80usize,
        concat!("Size of: ", stringify!(OptixBuildInputCurveArray))
    );
    assert_eq!(
        ::std::mem::align_of::<OptixBuildInputCurveArray>(),
        8usize,
        concat!("Alignment of ", stringify!(OptixBuildInputCurveArray))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).curveType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInputCurveArray),
            "::",
            stringify!(curveType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numPrimitives) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInputCurveArray),
            "::",
            stringify!(numPrimitives)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vertexBuffers) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInputCurveArray),
            "::",
            stringify!(vertexBuffers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numVertices) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInputCurveArray),
            "::",
            stringify!(numVertices)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vertexStrideInBytes) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInputCurveArray),
            "::",
            stringify!(vertexStrideInBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).widthBuffers) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInputCurveArray),
            "::",
            stringify!(widthBuffers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).widthStrideInBytes) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInputCurveArray),
            "::",
            stringify!(widthStrideInBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).normalBuffers) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInputCurveArray),
            "::",
            stringify!(normalBuffers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).normalStrideInBytes) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInputCurveArray),
            "::",
            stringify!(normalStrideInBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).indexBuffer) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInputCurveArray),
            "::",
            stringify!(indexBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).indexStrideInBytes) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInputCurveArray),
            "::",
            stringify!(indexStrideInBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flag) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInputCurveArray),
            "::",
            stringify!(flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).primitiveIndexOffset) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInputCurveArray),
            "::",
            stringify!(primitiveIndexOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).endcapFlags) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInputCurveArray),
            "::",
            stringify!(endcapFlags)
        )
    );
}
impl Default for OptixBuildInputCurveArray {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Sphere inputs\n\n A sphere is defined by a center point and a radius.\n Each center point is represented by a vertex in the vertex buffer.\n There is either a single radius for all spheres, or the radii are represented by entries in the radius buffer.\n\n The vertex buffers and radius buffers point to a host array of device pointers, one per motion step.\n Host array size must match the number of motion keys as set in #OptixMotionOptions (or an array of size 1 if OptixMotionOptions::numKeys is set\n to 0 or 1). Each per motion key device pointer must point to an array of vertices corresponding to the center points of the spheres, or\n an array of 1 or N radii. Format OPTIX_VERTEX_FORMAT_FLOAT3 is used for vertices, OPTIX_VERTEX_FORMAT_FLOAT for radii.\n\n \\see #OptixBuildInput::sphereArray"]
#[repr(C)]
pub struct OptixBuildInputSphereArray {
    #[doc = " Pointer to host array of device pointers, one per motion step. Host array size must match number of\n motion keys as set in #OptixMotionOptions (or an array of size 1 if OptixMotionOptions::numKeys is set\n to 1). Each per-motion-key device pointer must point to an array of floats (the center points of\n the spheres)."]
    pub vertexBuffers: *const CUdeviceptr,
    #[doc = " Stride between vertices. If set to zero, vertices are assumed to be tightly\n packed and stride is sizeof( float3 )."]
    pub vertexStrideInBytes: ::std::os::raw::c_uint,
    #[doc = " Number of vertices in each buffer in vertexBuffers."]
    pub numVertices: ::std::os::raw::c_uint,
    #[doc = " Parallel to vertexBuffers: a device pointer per motion step, each with numRadii float values,\n specifying the sphere radius corresponding to each vertex."]
    pub radiusBuffers: *const CUdeviceptr,
    #[doc = " Stride between radii. If set to zero, widths are assumed to be tightly\n packed and stride is sizeof( float )."]
    pub radiusStrideInBytes: ::std::os::raw::c_uint,
    #[doc = " Boolean value indicating whether a single radius per radius buffer is used,\n or the number of radii in radiusBuffers equals numVertices."]
    pub singleRadius: ::std::os::raw::c_int,
    #[doc = " Array of flags, to specify flags per sbt record,\n combinations of OptixGeometryFlags describing the\n primitive behavior, size must match numSbtRecords"]
    pub flags: *const ::std::os::raw::c_uint,
    #[doc = " Number of sbt records available to the sbt index offset override."]
    pub numSbtRecords: ::std::os::raw::c_uint,
    #[doc = " Device pointer to per-primitive local sbt index offset buffer. May be NULL.\n Every entry must be in range [0,numSbtRecords-1].\n Size needs to be the number of primitives."]
    pub sbtIndexOffsetBuffer: CUdeviceptr,
    #[doc = " Size of type of the sbt index offset. Needs to be 0, 1, 2 or 4 (8, 16 or 32 bit)."]
    pub sbtIndexOffsetSizeInBytes: ::std::os::raw::c_uint,
    #[doc = " Stride between the sbt index offsets. If set to zero, the offsets are assumed to be tightly\n packed and the stride matches the size of the type (sbtIndexOffsetSizeInBytes)."]
    pub sbtIndexOffsetStrideInBytes: ::std::os::raw::c_uint,
    #[doc = " Primitive index bias, applied in optixGetPrimitiveIndex().\n Sum of primitiveIndexOffset and number of primitives must not overflow 32bits."]
    pub primitiveIndexOffset: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_OptixBuildInputSphereArray() {
    const UNINIT: ::std::mem::MaybeUninit<OptixBuildInputSphereArray> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OptixBuildInputSphereArray>(),
        72usize,
        concat!("Size of: ", stringify!(OptixBuildInputSphereArray))
    );
    assert_eq!(
        ::std::mem::align_of::<OptixBuildInputSphereArray>(),
        8usize,
        concat!("Alignment of ", stringify!(OptixBuildInputSphereArray))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vertexBuffers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInputSphereArray),
            "::",
            stringify!(vertexBuffers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vertexStrideInBytes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInputSphereArray),
            "::",
            stringify!(vertexStrideInBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numVertices) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInputSphereArray),
            "::",
            stringify!(numVertices)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).radiusBuffers) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInputSphereArray),
            "::",
            stringify!(radiusBuffers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).radiusStrideInBytes) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInputSphereArray),
            "::",
            stringify!(radiusStrideInBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).singleRadius) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInputSphereArray),
            "::",
            stringify!(singleRadius)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInputSphereArray),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numSbtRecords) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInputSphereArray),
            "::",
            stringify!(numSbtRecords)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sbtIndexOffsetBuffer) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInputSphereArray),
            "::",
            stringify!(sbtIndexOffsetBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sbtIndexOffsetSizeInBytes) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInputSphereArray),
            "::",
            stringify!(sbtIndexOffsetSizeInBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sbtIndexOffsetStrideInBytes) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInputSphereArray),
            "::",
            stringify!(sbtIndexOffsetStrideInBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).primitiveIndexOffset) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInputSphereArray),
            "::",
            stringify!(primitiveIndexOffset)
        )
    );
}
impl Default for OptixBuildInputSphereArray {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " AABB inputs"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct OptixAabb {
    #[doc = "< Lower extent in X direction."]
    pub minX: f32,
    #[doc = "< Lower extent in Y direction."]
    pub minY: f32,
    #[doc = "< Lower extent in Z direction."]
    pub minZ: f32,
    #[doc = "< Upper extent in X direction."]
    pub maxX: f32,
    #[doc = "< Upper extent in Y direction."]
    pub maxY: f32,
    #[doc = "< Upper extent in Z direction."]
    pub maxZ: f32,
}
#[test]
fn bindgen_test_layout_OptixAabb() {
    const UNINIT: ::std::mem::MaybeUninit<OptixAabb> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OptixAabb>(),
        24usize,
        concat!("Size of: ", stringify!(OptixAabb))
    );
    assert_eq!(
        ::std::mem::align_of::<OptixAabb>(),
        4usize,
        concat!("Alignment of ", stringify!(OptixAabb))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minX) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixAabb),
            "::",
            stringify!(minX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minY) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixAabb),
            "::",
            stringify!(minY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minZ) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixAabb),
            "::",
            stringify!(minZ)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxX) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixAabb),
            "::",
            stringify!(maxX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxY) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixAabb),
            "::",
            stringify!(maxY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxZ) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixAabb),
            "::",
            stringify!(maxZ)
        )
    );
}
#[doc = " Custom primitive inputs\n\n \\see #OptixBuildInput::customPrimitiveArray"]
#[repr(C)]
pub struct OptixBuildInputCustomPrimitiveArray {
    #[doc = " Points to host array of device pointers to AABBs (type OptixAabb), one per motion step.\n Host array size must match number of motion keys as set in OptixMotionOptions (or an array of size 1\n if OptixMotionOptions::numKeys is set to 1).\n Each device pointer must be a multiple of OPTIX_AABB_BUFFER_BYTE_ALIGNMENT."]
    pub aabbBuffers: *const CUdeviceptr,
    #[doc = " Number of primitives in each buffer (i.e., per motion step) in\n #OptixBuildInputCustomPrimitiveArray::aabbBuffers."]
    pub numPrimitives: ::std::os::raw::c_uint,
    #[doc = " Stride between AABBs (per motion key). If set to zero, the aabbs are assumed to be tightly\n packed and the stride is assumed to be sizeof( OptixAabb ).\n If non-zero, the value must be a multiple of OPTIX_AABB_BUFFER_BYTE_ALIGNMENT."]
    pub strideInBytes: ::std::os::raw::c_uint,
    #[doc = " Array of flags, to specify flags per sbt record,\n combinations of OptixGeometryFlags describing the\n primitive behavior, size must match numSbtRecords"]
    pub flags: *const ::std::os::raw::c_uint,
    #[doc = " Number of sbt records available to the sbt index offset override."]
    pub numSbtRecords: ::std::os::raw::c_uint,
    #[doc = " Device pointer to per-primitive local sbt index offset buffer. May be NULL.\n Every entry must be in range [0,numSbtRecords-1].\n Size needs to be the number of primitives."]
    pub sbtIndexOffsetBuffer: CUdeviceptr,
    #[doc = " Size of type of the sbt index offset. Needs to be 0, 1, 2 or 4 (8, 16 or 32 bit)."]
    pub sbtIndexOffsetSizeInBytes: ::std::os::raw::c_uint,
    #[doc = " Stride between the index offsets. If set to zero, the offsets are assumed to be tightly\n packed and the stride matches the size of the type (sbtIndexOffsetSizeInBytes)."]
    pub sbtIndexOffsetStrideInBytes: ::std::os::raw::c_uint,
    #[doc = " Primitive index bias, applied in optixGetPrimitiveIndex().\n Sum of primitiveIndexOffset and number of primitive must not overflow 32bits."]
    pub primitiveIndexOffset: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_OptixBuildInputCustomPrimitiveArray() {
    const UNINIT: ::std::mem::MaybeUninit<OptixBuildInputCustomPrimitiveArray> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OptixBuildInputCustomPrimitiveArray>(),
        56usize,
        concat!("Size of: ", stringify!(OptixBuildInputCustomPrimitiveArray))
    );
    assert_eq!(
        ::std::mem::align_of::<OptixBuildInputCustomPrimitiveArray>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(OptixBuildInputCustomPrimitiveArray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aabbBuffers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInputCustomPrimitiveArray),
            "::",
            stringify!(aabbBuffers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numPrimitives) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInputCustomPrimitiveArray),
            "::",
            stringify!(numPrimitives)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).strideInBytes) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInputCustomPrimitiveArray),
            "::",
            stringify!(strideInBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInputCustomPrimitiveArray),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numSbtRecords) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInputCustomPrimitiveArray),
            "::",
            stringify!(numSbtRecords)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sbtIndexOffsetBuffer) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInputCustomPrimitiveArray),
            "::",
            stringify!(sbtIndexOffsetBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sbtIndexOffsetSizeInBytes) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInputCustomPrimitiveArray),
            "::",
            stringify!(sbtIndexOffsetSizeInBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sbtIndexOffsetStrideInBytes) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInputCustomPrimitiveArray),
            "::",
            stringify!(sbtIndexOffsetStrideInBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).primitiveIndexOffset) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInputCustomPrimitiveArray),
            "::",
            stringify!(primitiveIndexOffset)
        )
    );
}
impl Default for OptixBuildInputCustomPrimitiveArray {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Instance and instance pointer inputs\n\n \\see #OptixBuildInput::instanceArray"]
#[repr(C)]
pub struct OptixBuildInputInstanceArray {
    #[doc = " If OptixBuildInput::type is OPTIX_BUILD_INPUT_TYPE_INSTANCE_POINTERS instances and\n aabbs should be interpreted as arrays of pointers instead of arrays of structs.\n\n This pointer must be a multiple of OPTIX_INSTANCE_BYTE_ALIGNMENT if\n OptixBuildInput::type is OPTIX_BUILD_INPUT_TYPE_INSTANCES. The array elements must\n be a multiple of OPTIX_INSTANCE_BYTE_ALIGNMENT if OptixBuildInput::type is\n OPTIX_BUILD_INPUT_TYPE_INSTANCE_POINTERS."]
    pub instances: CUdeviceptr,
    #[doc = " Number of elements in #OptixBuildInputInstanceArray::instances."]
    pub numInstances: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_OptixBuildInputInstanceArray() {
    const UNINIT: ::std::mem::MaybeUninit<OptixBuildInputInstanceArray> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OptixBuildInputInstanceArray>(),
        16usize,
        concat!("Size of: ", stringify!(OptixBuildInputInstanceArray))
    );
    assert_eq!(
        ::std::mem::align_of::<OptixBuildInputInstanceArray>(),
        8usize,
        concat!("Alignment of ", stringify!(OptixBuildInputInstanceArray))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instances) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInputInstanceArray),
            "::",
            stringify!(instances)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numInstances) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInputInstanceArray),
            "::",
            stringify!(numInstances)
        )
    );
}
impl Default for OptixBuildInputInstanceArray {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[doc = " Enum to distinguish the different build input types.\n\n \\see #OptixBuildInput::type"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum OptixBuildInputType {
    #[doc = " Triangle inputs. \\see #OptixBuildInputTriangleArray"]
    OPTIX_BUILD_INPUT_TYPE_TRIANGLES = 8513,
    #[doc = " Custom primitive inputs. \\see #OptixBuildInputCustomPrimitiveArray"]
    OPTIX_BUILD_INPUT_TYPE_CUSTOM_PRIMITIVES = 8514,
    #[doc = " Instance inputs. \\see #OptixBuildInputInstanceArray"]
    OPTIX_BUILD_INPUT_TYPE_INSTANCES = 8515,
    #[doc = " Instance pointer inputs. \\see #OptixBuildInputInstanceArray"]
    OPTIX_BUILD_INPUT_TYPE_INSTANCE_POINTERS = 8516,
    #[doc = " Curve inputs. \\see #OptixBuildInputCurveArray"]
    OPTIX_BUILD_INPUT_TYPE_CURVES = 8517,
    #[doc = " Sphere inputs. \\see #OptixBuildInputSphereArray"]
    OPTIX_BUILD_INPUT_TYPE_SPHERES = 8518,
}
#[doc = " Build inputs.\n\n All of them support motion and the size of the data arrays needs to match the number of motion steps\n\n \\see #optixAccelComputeMemoryUsage(), #optixAccelBuild()"]
#[repr(C)]
pub struct OptixBuildInput {
    #[doc = " The type of the build input."]
    pub type_: OptixBuildInputType,
    pub __bindgen_anon_1: OptixBuildInput__bindgen_ty_1,
}
#[repr(C)]
pub struct OptixBuildInput__bindgen_ty_1 {
    #[doc = " Triangle inputs."]
    pub triangleArray: __BindgenUnionField<OptixBuildInputTriangleArray>,
    #[doc = " Curve inputs."]
    pub curveArray: __BindgenUnionField<OptixBuildInputCurveArray>,
    #[doc = " Sphere inputs."]
    pub sphereArray: __BindgenUnionField<OptixBuildInputSphereArray>,
    #[doc = " Custom primitive inputs."]
    pub customPrimitiveArray: __BindgenUnionField<OptixBuildInputCustomPrimitiveArray>,
    #[doc = " Instance and instance pointer inputs."]
    pub instanceArray: __BindgenUnionField<OptixBuildInputInstanceArray>,
    pub pad: __BindgenUnionField<[::std::os::raw::c_char; 1024usize]>,
    pub bindgen_union_field: [u64; 128usize],
}
#[test]
fn bindgen_test_layout_OptixBuildInput__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<OptixBuildInput__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OptixBuildInput__bindgen_ty_1>(),
        1024usize,
        concat!("Size of: ", stringify!(OptixBuildInput__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<OptixBuildInput__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(OptixBuildInput__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).triangleArray) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInput__bindgen_ty_1),
            "::",
            stringify!(triangleArray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).curveArray) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInput__bindgen_ty_1),
            "::",
            stringify!(curveArray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sphereArray) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInput__bindgen_ty_1),
            "::",
            stringify!(sphereArray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).customPrimitiveArray) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInput__bindgen_ty_1),
            "::",
            stringify!(customPrimitiveArray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instanceArray) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInput__bindgen_ty_1),
            "::",
            stringify!(instanceArray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInput__bindgen_ty_1),
            "::",
            stringify!(pad)
        )
    );
}
impl Default for OptixBuildInput__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_OptixBuildInput() {
    const UNINIT: ::std::mem::MaybeUninit<OptixBuildInput> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OptixBuildInput>(),
        1032usize,
        concat!("Size of: ", stringify!(OptixBuildInput))
    );
    assert_eq!(
        ::std::mem::align_of::<OptixBuildInput>(),
        8usize,
        concat!("Alignment of ", stringify!(OptixBuildInput))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuildInput),
            "::",
            stringify!(type_)
        )
    );
}
impl Default for OptixBuildInput {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[doc = " Flags set on the #OptixInstance::flags.\n\n These can be or'ed together to combine multiple flags."]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum OptixInstanceFlags {
    #[doc = " No special flag set"]
    OPTIX_INSTANCE_FLAG_NONE = 0,
    #[doc = " Prevent triangles from getting culled due to their orientation.\n Effectively ignores ray flags\n OPTIX_RAY_FLAG_CULL_BACK_FACING_TRIANGLES and OPTIX_RAY_FLAG_CULL_FRONT_FACING_TRIANGLES."]
    OPTIX_INSTANCE_FLAG_DISABLE_TRIANGLE_FACE_CULLING = 1,
    #[doc = " Flip triangle orientation.\n This affects front/backface culling as well as the reported face in case of a hit."]
    OPTIX_INSTANCE_FLAG_FLIP_TRIANGLE_FACING = 2,
    #[doc = " Disable anyhit programs for all geometries of the instance.\n Can be overridden by OPTIX_RAY_FLAG_ENFORCE_ANYHIT.\n This flag is mutually exclusive with OPTIX_INSTANCE_FLAG_ENFORCE_ANYHIT."]
    OPTIX_INSTANCE_FLAG_DISABLE_ANYHIT = 4,
    #[doc = " Enables anyhit programs for all geometries of the instance.\n Overrides OPTIX_GEOMETRY_FLAG_DISABLE_ANYHIT\n Can be overridden by OPTIX_RAY_FLAG_DISABLE_ANYHIT.\n This flag is mutually exclusive with OPTIX_INSTANCE_FLAG_DISABLE_ANYHIT."]
    OPTIX_INSTANCE_FLAG_ENFORCE_ANYHIT = 8,
}
#[doc = " Instances\n\n \\see #OptixBuildInputInstanceArray::instances"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct OptixInstance {
    #[doc = " affine object-to-world transformation as 3x4 matrix in row-major layout"]
    pub transform: [f32; 12usize],
    #[doc = " Application supplied ID. The maximal ID can be queried using OPTIX_DEVICE_PROPERTY_LIMIT_MAX_INSTANCE_ID."]
    pub instanceId: ::std::os::raw::c_uint,
    #[doc = " SBT record offset.  Will only be used for instances of geometry acceleration structure (GAS) objects.\n Needs to be set to 0 for instances of instance acceleration structure (IAS) objects. The maximal SBT offset\n can be queried using OPTIX_DEVICE_PROPERTY_LIMIT_MAX_INSTANCE_SBT_OFFSET."]
    pub sbtOffset: ::std::os::raw::c_uint,
    #[doc = " Visibility mask. If rayMask & instanceMask == 0 the instance is culled. The number of available bits can be\n queried using OPTIX_DEVICE_PROPERTY_LIMIT_NUM_BITS_INSTANCE_VISIBILITY_MASK."]
    pub visibilityMask: ::std::os::raw::c_uint,
    #[doc = " Any combination of OptixInstanceFlags is allowed."]
    pub flags: ::std::os::raw::c_uint,
    #[doc = " Set with an OptixTraversableHandle."]
    pub traversableHandle: OptixTraversableHandle,
    #[doc = " round up to 80-byte, to ensure 16-byte alignment"]
    pub pad: [::std::os::raw::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout_OptixInstance() {
    const UNINIT: ::std::mem::MaybeUninit<OptixInstance> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OptixInstance>(),
        80usize,
        concat!("Size of: ", stringify!(OptixInstance))
    );
    assert_eq!(
        ::std::mem::align_of::<OptixInstance>(),
        8usize,
        concat!("Alignment of ", stringify!(OptixInstance))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transform) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixInstance),
            "::",
            stringify!(transform)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instanceId) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixInstance),
            "::",
            stringify!(instanceId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sbtOffset) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixInstance),
            "::",
            stringify!(sbtOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).visibilityMask) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixInstance),
            "::",
            stringify!(visibilityMask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixInstance),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).traversableHandle) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixInstance),
            "::",
            stringify!(traversableHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixInstance),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(u32)]
#[doc = " Builder Options\n\n Used for #OptixAccelBuildOptions::buildFlags. Can be or'ed together."]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum OptixBuildFlags {
    #[doc = " No special flags set."]
    OPTIX_BUILD_FLAG_NONE = 0,
    #[doc = " Allow updating the build with new vertex positions with subsequent calls to\n optixAccelBuild."]
    OPTIX_BUILD_FLAG_ALLOW_UPDATE = 1,
    #[doc = " Allow updating the build with new vertex positions with subsequent calls to\n optixAccelBuild."]
    OPTIX_BUILD_FLAG_ALLOW_COMPACTION = 2,
    #[doc = " Allow updating the build with new vertex positions with subsequent calls to\n optixAccelBuild."]
    OPTIX_BUILD_FLAG_PREFER_FAST_TRACE = 4,
    #[doc = " Allow updating the build with new vertex positions with subsequent calls to\n optixAccelBuild."]
    OPTIX_BUILD_FLAG_PREFER_FAST_BUILD = 8,
    #[doc = " Allow random access to build input vertices\n See optixGetTriangleVertexData\n     optixGetLinearCurveVertexData\n     optixGetQuadraticBSplineVertexData\n     optixGetCubicBSplineVertexData\n     optixGetCatmullRomVertexData\n     optixGetSphereData"]
    OPTIX_BUILD_FLAG_ALLOW_RANDOM_VERTEX_ACCESS = 16,
    #[doc = " Allow random access to instances\n See optixGetInstanceTraversableFromIAS"]
    OPTIX_BUILD_FLAG_ALLOW_RANDOM_INSTANCE_ACCESS = 32,
}
#[repr(u32)]
#[doc = " Enum to specify the acceleration build operation.\n\n Used in OptixAccelBuildOptions, which is then passed to optixAccelBuild and\n optixAccelComputeMemoryUsage, this enum indicates whether to do a build or an update\n of the acceleration structure.\n\n Acceleration structure updates utilize the same acceleration structure, but with\n updated bounds.  Updates are typically much faster than builds, however, large\n perturbations can degrade the quality of the acceleration structure.\n\n \\see #optixAccelComputeMemoryUsage(), #optixAccelBuild(), #OptixAccelBuildOptions"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum OptixBuildOperation {
    #[doc = " Perform a full build operation"]
    OPTIX_BUILD_OPERATION_BUILD = 8545,
    #[doc = " Perform an update using new bounds"]
    OPTIX_BUILD_OPERATION_UPDATE = 8546,
}
#[repr(u32)]
#[doc = " Enum to specify motion flags.\n\n \\see #OptixMotionOptions::flags."]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum OptixMotionFlags {
    OPTIX_MOTION_FLAG_NONE = 0,
    OPTIX_MOTION_FLAG_START_VANISH = 1,
    OPTIX_MOTION_FLAG_END_VANISH = 2,
}
#[doc = " Motion options\n\n \\see #OptixAccelBuildOptions::motionOptions, #OptixMatrixMotionTransform::motionOptions,\n      #OptixSRTMotionTransform::motionOptions"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct OptixMotionOptions {
    #[doc = " If numKeys > 1, motion is enabled. timeBegin,\n timeEnd and flags are all ignored when motion is disabled."]
    pub numKeys: ::std::os::raw::c_ushort,
    #[doc = " Combinations of #OptixMotionFlags"]
    pub flags: ::std::os::raw::c_ushort,
    #[doc = " Point in time where motion starts."]
    pub timeBegin: f32,
    #[doc = " Point in time where motion ends."]
    pub timeEnd: f32,
}
#[test]
fn bindgen_test_layout_OptixMotionOptions() {
    const UNINIT: ::std::mem::MaybeUninit<OptixMotionOptions> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OptixMotionOptions>(),
        12usize,
        concat!("Size of: ", stringify!(OptixMotionOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<OptixMotionOptions>(),
        4usize,
        concat!("Alignment of ", stringify!(OptixMotionOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numKeys) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixMotionOptions),
            "::",
            stringify!(numKeys)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixMotionOptions),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeBegin) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixMotionOptions),
            "::",
            stringify!(timeBegin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeEnd) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixMotionOptions),
            "::",
            stringify!(timeEnd)
        )
    );
}
#[doc = " Build options for acceleration structures.\n\n \\see #optixAccelComputeMemoryUsage(), #optixAccelBuild()"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, PartialEq)]
pub struct OptixAccelBuildOptions {
    #[doc = " Combinations of OptixBuildFlags"]
    pub buildFlags: ::std::os::raw::c_uint,
    #[doc = " If OPTIX_BUILD_OPERATION_UPDATE the output buffer is assumed to contain the result\n of a full build with OPTIX_BUILD_FLAG_ALLOW_UPDATE set and using the same number of\n primitives.  It is updated incrementally to reflect the current position of the\n primitives."]
    pub operation: OptixBuildOperation,
    #[doc = " Options for motion."]
    pub motionOptions: OptixMotionOptions,
}
#[test]
fn bindgen_test_layout_OptixAccelBuildOptions() {
    const UNINIT: ::std::mem::MaybeUninit<OptixAccelBuildOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OptixAccelBuildOptions>(),
        20usize,
        concat!("Size of: ", stringify!(OptixAccelBuildOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<OptixAccelBuildOptions>(),
        4usize,
        concat!("Alignment of ", stringify!(OptixAccelBuildOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buildFlags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixAccelBuildOptions),
            "::",
            stringify!(buildFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).operation) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixAccelBuildOptions),
            "::",
            stringify!(operation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).motionOptions) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixAccelBuildOptions),
            "::",
            stringify!(motionOptions)
        )
    );
}
impl Default for OptixAccelBuildOptions {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Struct for querying builder allocation requirements.\n\n Once queried the sizes should be used to allocate device memory of at least these sizes.\n\n \\see #optixAccelComputeMemoryUsage()"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct OptixAccelBufferSizes {
    #[doc = " The size in bytes required for the outputBuffer parameter to optixAccelBuild when\n doing a build (OPTIX_BUILD_OPERATION_BUILD)."]
    pub outputSizeInBytes: usize,
    #[doc = " The size in bytes required for the tempBuffer paramter to optixAccelBuild when\n doing a build (OPTIX_BUILD_OPERATION_BUILD)."]
    pub tempSizeInBytes: usize,
    #[doc = " The size in bytes required for the tempBuffer parameter to optixAccelBuild\n when doing an update (OPTIX_BUILD_OPERATION_UPDATE).  This value can be different\n than tempSizeInBytes used for a full build.  Only non-zero if\n OPTIX_BUILD_FLAG_ALLOW_UPDATE flag is set in OptixAccelBuildOptions."]
    pub tempUpdateSizeInBytes: usize,
}
#[test]
fn bindgen_test_layout_OptixAccelBufferSizes() {
    const UNINIT: ::std::mem::MaybeUninit<OptixAccelBufferSizes> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OptixAccelBufferSizes>(),
        24usize,
        concat!("Size of: ", stringify!(OptixAccelBufferSizes))
    );
    assert_eq!(
        ::std::mem::align_of::<OptixAccelBufferSizes>(),
        8usize,
        concat!("Alignment of ", stringify!(OptixAccelBufferSizes))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outputSizeInBytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixAccelBufferSizes),
            "::",
            stringify!(outputSizeInBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tempSizeInBytes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixAccelBufferSizes),
            "::",
            stringify!(tempSizeInBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tempUpdateSizeInBytes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixAccelBufferSizes),
            "::",
            stringify!(tempUpdateSizeInBytes)
        )
    );
}
#[repr(u32)]
#[doc = " Properties which can be emitted during acceleration structure build.\n\n \\see #OptixAccelEmitDesc::type."]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum OptixAccelPropertyType {
    #[doc = " Size of a compacted acceleration structure. The device pointer points to a uint64."]
    OPTIX_PROPERTY_TYPE_COMPACTED_SIZE = 8577,
    #[doc = " OptixAabb * numMotionSteps"]
    OPTIX_PROPERTY_TYPE_AABBS = 8578,
}
#[doc = " Specifies a type and output destination for emitted post-build properties.\n\n \\see #optixAccelBuild()"]
#[repr(C)]
pub struct OptixAccelEmitDesc {
    #[doc = " Output buffer for the properties"]
    pub result: CUdeviceptr,
    #[doc = " Requested property"]
    pub type_: OptixAccelPropertyType,
}
#[test]
fn bindgen_test_layout_OptixAccelEmitDesc() {
    const UNINIT: ::std::mem::MaybeUninit<OptixAccelEmitDesc> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OptixAccelEmitDesc>(),
        16usize,
        concat!("Size of: ", stringify!(OptixAccelEmitDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<OptixAccelEmitDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(OptixAccelEmitDesc))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).result) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixAccelEmitDesc),
            "::",
            stringify!(result)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixAccelEmitDesc),
            "::",
            stringify!(type_)
        )
    );
}
impl Default for OptixAccelEmitDesc {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Used to store information related to relocation of acceleration structures.\n\n \\see #optixAccelGetRelocationInfo(), #optixAccelCheckRelocationCompatibility(), #optixAccelRelocate()"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct OptixAccelRelocationInfo {
    #[doc = " Opaque data, used internally, should not be modified"]
    pub info: [::std::os::raw::c_ulonglong; 4usize],
}
#[test]
fn bindgen_test_layout_OptixAccelRelocationInfo() {
    const UNINIT: ::std::mem::MaybeUninit<OptixAccelRelocationInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OptixAccelRelocationInfo>(),
        32usize,
        concat!("Size of: ", stringify!(OptixAccelRelocationInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<OptixAccelRelocationInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(OptixAccelRelocationInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixAccelRelocationInfo),
            "::",
            stringify!(info)
        )
    );
}
#[doc = " Static transform\n\n The device address of instances of this type must be a multiple of OPTIX_TRANSFORM_BYTE_ALIGNMENT.\n\n \\see #optixConvertPointerToTraversableHandle()"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct OptixStaticTransform {
    #[doc = " The traversable transformed by this transformation"]
    pub child: OptixTraversableHandle,
    #[doc = " Padding to make the transformations 16 byte aligned"]
    pub pad: [::std::os::raw::c_uint; 2usize],
    #[doc = " Affine object-to-world transformation as 3x4 matrix in row-major layout"]
    pub transform: [f32; 12usize],
    #[doc = " Affine world-to-object transformation as 3x4 matrix in row-major layout\n Must be the inverse of the transform matrix"]
    pub invTransform: [f32; 12usize],
}
#[test]
fn bindgen_test_layout_OptixStaticTransform() {
    const UNINIT: ::std::mem::MaybeUninit<OptixStaticTransform> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OptixStaticTransform>(),
        112usize,
        concat!("Size of: ", stringify!(OptixStaticTransform))
    );
    assert_eq!(
        ::std::mem::align_of::<OptixStaticTransform>(),
        8usize,
        concat!("Alignment of ", stringify!(OptixStaticTransform))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).child) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixStaticTransform),
            "::",
            stringify!(child)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixStaticTransform),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transform) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixStaticTransform),
            "::",
            stringify!(transform)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).invTransform) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixStaticTransform),
            "::",
            stringify!(invTransform)
        )
    );
}
#[doc = " Represents a matrix motion transformation.\n\n The device address of instances of this type must be a multiple of OPTIX_TRANSFORM_BYTE_ALIGNMENT.\n\n This struct, as defined here, handles only N=2 motion keys due to the fixed array length of its transform member.\n The following example shows how to create instances for an arbitrary number N of motion keys:\n\n \\code\n float matrixData[N][12];\n ... // setup matrixData\n\n size_t transformSizeInBytes = sizeof( OptixMatrixMotionTransform ) + ( N-2 ) * 12 * sizeof( float );\n OptixMatrixMotionTransform* matrixMoptionTransform = (OptixMatrixMotionTransform*) malloc( transformSizeInBytes );\n memset( matrixMoptionTransform, 0, transformSizeInBytes );\n\n ... // setup other members of matrixMoptionTransform\n matrixMoptionTransform->motionOptions.numKeys/// = N;\n memcpy( matrixMoptionTransform->transform, matrixData, N * 12 * sizeof( float ) );\n\n ... // copy matrixMoptionTransform to device memory\n free( matrixMoptionTransform )\n \\endcode\n\n \\see #optixConvertPointerToTraversableHandle()"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct OptixMatrixMotionTransform {
    #[doc = " The traversable that is transformed by this transformation"]
    pub child: OptixTraversableHandle,
    #[doc = " The motion options for this transformation"]
    pub motionOptions: OptixMotionOptions,
    #[doc = " Padding to make the transformation 16 byte aligned"]
    pub pad: [::std::os::raw::c_uint; 3usize],
    #[doc = " Affine object-to-world transformation as 3x4 matrix in row-major layout"]
    pub transform: [[f32; 12usize]; 2usize],
}
#[test]
fn bindgen_test_layout_OptixMatrixMotionTransform() {
    const UNINIT: ::std::mem::MaybeUninit<OptixMatrixMotionTransform> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OptixMatrixMotionTransform>(),
        128usize,
        concat!("Size of: ", stringify!(OptixMatrixMotionTransform))
    );
    assert_eq!(
        ::std::mem::align_of::<OptixMatrixMotionTransform>(),
        8usize,
        concat!("Alignment of ", stringify!(OptixMatrixMotionTransform))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).child) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixMatrixMotionTransform),
            "::",
            stringify!(child)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).motionOptions) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixMatrixMotionTransform),
            "::",
            stringify!(motionOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixMatrixMotionTransform),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transform) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixMatrixMotionTransform),
            "::",
            stringify!(transform)
        )
    );
}
#[doc = " defines another translation that is applied after the rotation. Typically, this translation includes\n the inverse translation from the matrix S to reverse the translation for the pivot point for R.\n\n To obtain the effective transformation at time t, the elements of the components of S, R, and T will be interpolated\n linearly. The components are then multiplied to obtain the combined transformation C = T * R * S. The transformation\n C is the effective object-to-world transformations at time t, and C^(-1) is the effective world-to-object\n transformation at time t.\n\n \\see #OptixSRTMotionTransform::srtData, #optixConvertPointerToTraversableHandle()"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct OptixSRTData {
    #[doc = " \\name Parameters describing the SRT transformation\n @{"]
    pub sx: f32,
    #[doc = " \\name Parameters describing the SRT transformation\n @{"]
    pub a: f32,
    #[doc = " \\name Parameters describing the SRT transformation\n @{"]
    pub b: f32,
    #[doc = " \\name Parameters describing the SRT transformation\n @{"]
    pub pvx: f32,
    #[doc = " \\name Parameters describing the SRT transformation\n @{"]
    pub sy: f32,
    #[doc = " \\name Parameters describing the SRT transformation\n @{"]
    pub c: f32,
    #[doc = " \\name Parameters describing the SRT transformation\n @{"]
    pub pvy: f32,
    #[doc = " \\name Parameters describing the SRT transformation\n @{"]
    pub sz: f32,
    #[doc = " \\name Parameters describing the SRT transformation\n @{"]
    pub pvz: f32,
    #[doc = " \\name Parameters describing the SRT transformation\n @{"]
    pub qx: f32,
    #[doc = " \\name Parameters describing the SRT transformation\n @{"]
    pub qy: f32,
    #[doc = " \\name Parameters describing the SRT transformation\n @{"]
    pub qz: f32,
    #[doc = " \\name Parameters describing the SRT transformation\n @{"]
    pub qw: f32,
    #[doc = " \\name Parameters describing the SRT transformation\n @{"]
    pub tx: f32,
    #[doc = " \\name Parameters describing the SRT transformation\n @{"]
    pub ty: f32,
    #[doc = " \\name Parameters describing the SRT transformation\n @{"]
    pub tz: f32,
}
#[test]
fn bindgen_test_layout_OptixSRTData() {
    const UNINIT: ::std::mem::MaybeUninit<OptixSRTData> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OptixSRTData>(),
        64usize,
        concat!("Size of: ", stringify!(OptixSRTData))
    );
    assert_eq!(
        ::std::mem::align_of::<OptixSRTData>(),
        4usize,
        concat!("Alignment of ", stringify!(OptixSRTData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixSRTData),
            "::",
            stringify!(sx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixSRTData),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixSRTData),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pvx) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixSRTData),
            "::",
            stringify!(pvx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sy) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixSRTData),
            "::",
            stringify!(sy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).c) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixSRTData),
            "::",
            stringify!(c)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pvy) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixSRTData),
            "::",
            stringify!(pvy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sz) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixSRTData),
            "::",
            stringify!(sz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pvz) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixSRTData),
            "::",
            stringify!(pvz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qx) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixSRTData),
            "::",
            stringify!(qx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qy) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixSRTData),
            "::",
            stringify!(qy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qz) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixSRTData),
            "::",
            stringify!(qz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qw) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixSRTData),
            "::",
            stringify!(qw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixSRTData),
            "::",
            stringify!(tx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ty) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixSRTData),
            "::",
            stringify!(ty)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tz) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixSRTData),
            "::",
            stringify!(tz)
        )
    );
}
#[doc = " Represents an SRT motion transformation.\n\n The device address of instances of this type must be a multiple of OPTIX_TRANSFORM_BYTE_ALIGNMENT.\n\n This struct, as defined here, handles only N=2 motion keys due to the fixed array length of its srtData member.\n The following example shows how to create instances for an arbitrary number N of motion keys:\n\n \\code\n OptixSRTData srtData[N];\n ... // setup srtData\n\n size_t transformSizeInBytes = sizeof( OptixSRTMotionTransform ) + ( N-2 ) * sizeof( OptixSRTData );\n OptixSRTMotionTransform* srtMotionTransform = (OptixSRTMotionTransform*) malloc( transformSizeInBytes );\n memset( srtMotionTransform, 0, transformSizeInBytes );\n\n ... // setup other members of srtMotionTransform\n srtMotionTransform->motionOptions.numKeys   = N;\n memcpy( srtMotionTransform->srtData, srtData, N * sizeof( OptixSRTData ) );\n\n ... // copy srtMotionTransform to device memory\n free( srtMotionTransform )\n \\endcode\n\n \\see #optixConvertPointerToTraversableHandle()"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct OptixSRTMotionTransform {
    #[doc = " The traversable transformed by this transformation"]
    pub child: OptixTraversableHandle,
    #[doc = " The motion options for this transformation"]
    pub motionOptions: OptixMotionOptions,
    #[doc = " Padding to make the SRT data 16 byte aligned"]
    pub pad: [::std::os::raw::c_uint; 3usize],
    #[doc = " The actual SRT data describing the transformation"]
    pub srtData: [OptixSRTData; 2usize],
}
#[test]
fn bindgen_test_layout_OptixSRTMotionTransform() {
    const UNINIT: ::std::mem::MaybeUninit<OptixSRTMotionTransform> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OptixSRTMotionTransform>(),
        160usize,
        concat!("Size of: ", stringify!(OptixSRTMotionTransform))
    );
    assert_eq!(
        ::std::mem::align_of::<OptixSRTMotionTransform>(),
        8usize,
        concat!("Alignment of ", stringify!(OptixSRTMotionTransform))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).child) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixSRTMotionTransform),
            "::",
            stringify!(child)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).motionOptions) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixSRTMotionTransform),
            "::",
            stringify!(motionOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixSRTMotionTransform),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srtData) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixSRTMotionTransform),
            "::",
            stringify!(srtData)
        )
    );
}
#[repr(u32)]
#[doc = " Traversable Handles\n\n \\see #optixConvertPointerToTraversableHandle()"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum OptixTraversableType {
    #[doc = " Static transforms. \\see #OptixStaticTransform"]
    OPTIX_TRAVERSABLE_TYPE_STATIC_TRANSFORM = 8641,
    #[doc = " Matrix motion transform. \\see #OptixMatrixMotionTransform"]
    OPTIX_TRAVERSABLE_TYPE_MATRIX_MOTION_TRANSFORM = 8642,
    #[doc = " SRT motion transform. \\see #OptixSRTMotionTransform"]
    OPTIX_TRAVERSABLE_TYPE_SRT_MOTION_TRANSFORM = 8643,
}
#[repr(u32)]
#[doc = " Pixel formats used by the denoiser.\n\n \\see #OptixImage2D::format"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum OptixPixelFormat {
    #[doc = "< two halfs, XY"]
    OPTIX_PIXEL_FORMAT_HALF2 = 8711,
    #[doc = "< three halfs, RGB"]
    OPTIX_PIXEL_FORMAT_HALF3 = 8705,
    #[doc = "< four halfs, RGBA"]
    OPTIX_PIXEL_FORMAT_HALF4 = 8706,
    #[doc = "< two floats, XY"]
    OPTIX_PIXEL_FORMAT_FLOAT2 = 8712,
    #[doc = "< three floats, RGB"]
    OPTIX_PIXEL_FORMAT_FLOAT3 = 8707,
    #[doc = "< four floats, RGBA"]
    OPTIX_PIXEL_FORMAT_FLOAT4 = 8708,
    #[doc = "< three unsigned chars, RGB"]
    OPTIX_PIXEL_FORMAT_UCHAR3 = 8709,
    #[doc = "< four unsigned chars, RGBA"]
    OPTIX_PIXEL_FORMAT_UCHAR4 = 8710,
    #[doc = "< internal format"]
    OPTIX_PIXEL_FORMAT_INTERNAL_GUIDE_LAYER = 8713,
}
#[doc = " Image descriptor used by the denoiser.\n\n \\see #optixDenoiserInvoke(), #optixDenoiserComputeIntensity()"]
#[repr(C)]
pub struct OptixImage2D {
    #[doc = " Pointer to the actual pixel data."]
    pub data: CUdeviceptr,
    #[doc = " Width of the image (in pixels)"]
    pub width: ::std::os::raw::c_uint,
    #[doc = " Height of the image (in pixels)"]
    pub height: ::std::os::raw::c_uint,
    #[doc = " Stride between subsequent rows of the image (in bytes)."]
    pub rowStrideInBytes: ::std::os::raw::c_uint,
    #[doc = " Stride between subsequent pixels of the image (in bytes).\n If set to 0, dense packing (no gaps) is assumed.\n For pixel format OPTIX_PIXEL_FORMAT_INTERNAL_GUIDE_LAYER it must be set to\n at least OptixDenoiserSizes::internalGuideLayerSizeInBytes."]
    pub pixelStrideInBytes: ::std::os::raw::c_uint,
    #[doc = " Pixel format."]
    pub format: OptixPixelFormat,
}
#[test]
fn bindgen_test_layout_OptixImage2D() {
    const UNINIT: ::std::mem::MaybeUninit<OptixImage2D> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OptixImage2D>(),
        32usize,
        concat!("Size of: ", stringify!(OptixImage2D))
    );
    assert_eq!(
        ::std::mem::align_of::<OptixImage2D>(),
        8usize,
        concat!("Alignment of ", stringify!(OptixImage2D))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixImage2D),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixImage2D),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixImage2D),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rowStrideInBytes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixImage2D),
            "::",
            stringify!(rowStrideInBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixelStrideInBytes) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixImage2D),
            "::",
            stringify!(pixelStrideInBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixImage2D),
            "::",
            stringify!(format)
        )
    );
}
impl Default for OptixImage2D {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[doc = " Model kind used by the denoiser.\n\n \\see #optixDenoiserCreate"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum OptixDenoiserModelKind {
    #[doc = " Use the built-in model appropriate for low dynamic range input."]
    OPTIX_DENOISER_MODEL_KIND_LDR = 8994,
    #[doc = " Use the built-in model appropriate for high dynamic range input."]
    OPTIX_DENOISER_MODEL_KIND_HDR = 8995,
    #[doc = " Use the built-in model appropriate for high dynamic range input and support for AOVs"]
    OPTIX_DENOISER_MODEL_KIND_AOV = 8996,
    #[doc = " Use the built-in model appropriate for high dynamic range input, temporally stable"]
    OPTIX_DENOISER_MODEL_KIND_TEMPORAL = 8997,
    #[doc = " Use the built-in model appropriate for high dynamic range input and support for AOVs, temporally stable"]
    OPTIX_DENOISER_MODEL_KIND_TEMPORAL_AOV = 8998,
    #[doc = " Use the built-in model appropriate for high dynamic range input and support for AOVs, upscaling 2x"]
    OPTIX_DENOISER_MODEL_KIND_UPSCALE2X = 8999,
    #[doc = " Use the built-in model appropriate for high dynamic range input and support for AOVs, upscaling 2x,\n temporally stable"]
    OPTIX_DENOISER_MODEL_KIND_TEMPORAL_UPSCALE2X = 9000,
}
#[doc = " Options used by the denoiser\n\n \\see #optixDenoiserCreate()"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct OptixDenoiserOptions {
    pub guideAlbedo: ::std::os::raw::c_uint,
    pub guideNormal: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_OptixDenoiserOptions() {
    const UNINIT: ::std::mem::MaybeUninit<OptixDenoiserOptions> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OptixDenoiserOptions>(),
        8usize,
        concat!("Size of: ", stringify!(OptixDenoiserOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<OptixDenoiserOptions>(),
        4usize,
        concat!("Alignment of ", stringify!(OptixDenoiserOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).guideAlbedo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixDenoiserOptions),
            "::",
            stringify!(guideAlbedo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).guideNormal) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixDenoiserOptions),
            "::",
            stringify!(guideNormal)
        )
    );
}
#[doc = " Guide layer for the denoiser\n\n \\see #optixDenoiserInvoke()"]
#[repr(C)]
pub struct OptixDenoiserGuideLayer {
    pub albedo: OptixImage2D,
    pub normal: OptixImage2D,
    pub flow: OptixImage2D,
    pub previousOutputInternalGuideLayer: OptixImage2D,
    pub outputInternalGuideLayer: OptixImage2D,
}
#[test]
fn bindgen_test_layout_OptixDenoiserGuideLayer() {
    const UNINIT: ::std::mem::MaybeUninit<OptixDenoiserGuideLayer> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OptixDenoiserGuideLayer>(),
        160usize,
        concat!("Size of: ", stringify!(OptixDenoiserGuideLayer))
    );
    assert_eq!(
        ::std::mem::align_of::<OptixDenoiserGuideLayer>(),
        8usize,
        concat!("Alignment of ", stringify!(OptixDenoiserGuideLayer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).albedo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixDenoiserGuideLayer),
            "::",
            stringify!(albedo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).normal) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixDenoiserGuideLayer),
            "::",
            stringify!(normal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flow) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixDenoiserGuideLayer),
            "::",
            stringify!(flow)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).previousOutputInternalGuideLayer) as usize - ptr as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixDenoiserGuideLayer),
            "::",
            stringify!(previousOutputInternalGuideLayer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outputInternalGuideLayer) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixDenoiserGuideLayer),
            "::",
            stringify!(outputInternalGuideLayer)
        )
    );
}
impl Default for OptixDenoiserGuideLayer {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Input/Output layers for the denoiser\n\n \\see #optixDenoiserInvoke()"]
#[repr(C)]
pub struct OptixDenoiserLayer {
    pub input: OptixImage2D,
    pub previousOutput: OptixImage2D,
    pub output: OptixImage2D,
}
#[test]
fn bindgen_test_layout_OptixDenoiserLayer() {
    const UNINIT: ::std::mem::MaybeUninit<OptixDenoiserLayer> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OptixDenoiserLayer>(),
        96usize,
        concat!("Size of: ", stringify!(OptixDenoiserLayer))
    );
    assert_eq!(
        ::std::mem::align_of::<OptixDenoiserLayer>(),
        8usize,
        concat!("Alignment of ", stringify!(OptixDenoiserLayer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixDenoiserLayer),
            "::",
            stringify!(input)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).previousOutput) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixDenoiserLayer),
            "::",
            stringify!(previousOutput)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixDenoiserLayer),
            "::",
            stringify!(output)
        )
    );
}
impl Default for OptixDenoiserLayer {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[doc = " Various parameters used by the denoiser\n\n \\see #optixDenoiserInvoke()\n \\see #optixDenoiserComputeIntensity()\n \\see #optixDenoiserComputeAverageColor()"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum OptixDenoiserAlphaMode {
    #[doc = " Copy alpha (if present) from input layer, no denoising."]
    OPTIX_DENOISER_ALPHA_MODE_COPY = 0,
    #[doc = " Denoise alpha separately. With AOV model kinds, treat alpha like an AOV."]
    OPTIX_DENOISER_ALPHA_MODE_ALPHA_AS_AOV = 1,
    #[doc = " With AOV model kinds, full denoise pass with alpha.\n This is slower than OPTIX_DENOISER_ALPHA_MODE_ALPHA_AS_AOV."]
    OPTIX_DENOISER_ALPHA_MODE_FULL_DENOISE_PASS = 2,
}
#[repr(C)]
pub struct OptixDenoiserParams {
    #[doc = " alpha denoise mode"]
    pub denoiseAlpha: OptixDenoiserAlphaMode,
    #[doc = " average log intensity of input image (default null pointer). points to a single float.\n with the default (null pointer) denoised results will not be optimal for very dark or\n bright input images."]
    pub hdrIntensity: CUdeviceptr,
    #[doc = " blend factor.\n If set to 0 the output is 100% of the denoised input. If set to 1, the output is 100% of\n the unmodified input. Values between 0 and 1 will linearly interpolate between the denoised\n and unmodified input."]
    pub blendFactor: f32,
    #[doc = " this parameter is used when the OPTIX_DENOISER_MODEL_KIND_AOV model kind is set.\n average log color of input image, separate for RGB channels (default null pointer).\n points to three floats. with the default (null pointer) denoised results will not be\n optimal."]
    pub hdrAverageColor: CUdeviceptr,
    #[doc = " In temporal modes this parameter must be set to 1 if previous layers (e.g.\n previousOutputInternalGuideLayer) contain valid data. This is the case in the\n second and subsequent frames of a sequence (for example after a change of camera\n angle). In the first frame of such a sequence this parameter must be set to 0."]
    pub temporalModeUsePreviousLayers: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_OptixDenoiserParams() {
    const UNINIT: ::std::mem::MaybeUninit<OptixDenoiserParams> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OptixDenoiserParams>(),
        40usize,
        concat!("Size of: ", stringify!(OptixDenoiserParams))
    );
    assert_eq!(
        ::std::mem::align_of::<OptixDenoiserParams>(),
        8usize,
        concat!("Alignment of ", stringify!(OptixDenoiserParams))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).denoiseAlpha) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixDenoiserParams),
            "::",
            stringify!(denoiseAlpha)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdrIntensity) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixDenoiserParams),
            "::",
            stringify!(hdrIntensity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blendFactor) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixDenoiserParams),
            "::",
            stringify!(blendFactor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdrAverageColor) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixDenoiserParams),
            "::",
            stringify!(hdrAverageColor)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).temporalModeUsePreviousLayers) as usize - ptr as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixDenoiserParams),
            "::",
            stringify!(temporalModeUsePreviousLayers)
        )
    );
}
impl Default for OptixDenoiserParams {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Various sizes related to the denoiser.\n\n \\see #optixDenoiserComputeMemoryResources()"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct OptixDenoiserSizes {
    #[doc = " Size of state memory passed to #optixDenoiserSetup, #optixDenoiserInvoke."]
    pub stateSizeInBytes: usize,
    #[doc = " Size of scratch memory passed to #optixDenoiserSetup, #optixDenoiserInvoke.\n Overlap added to dimensions passed to #optixDenoiserComputeMemoryResources."]
    pub withOverlapScratchSizeInBytes: usize,
    #[doc = " Size of scratch memory passed to #optixDenoiserSetup, #optixDenoiserInvoke.\n No overlap added."]
    pub withoutOverlapScratchSizeInBytes: usize,
    #[doc = " Overlap on all four tile sides."]
    pub overlapWindowSizeInPixels: ::std::os::raw::c_uint,
    #[doc = " Size of scratch memory passed to #optixDenoiserComputeAverageColor.\n The size is independent of the tile/image resolution."]
    pub computeAverageColorSizeInBytes: usize,
    #[doc = " Size of scratch memory passed to #optixDenoiserComputeIntensity.\n The size is independent of the tile/image resolution."]
    pub computeIntensitySizeInBytes: usize,
    #[doc = " Number of bytes for each pixel in internal guide layers."]
    pub internalGuideLayerPixelSizeInBytes: usize,
}
#[test]
fn bindgen_test_layout_OptixDenoiserSizes() {
    const UNINIT: ::std::mem::MaybeUninit<OptixDenoiserSizes> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OptixDenoiserSizes>(),
        56usize,
        concat!("Size of: ", stringify!(OptixDenoiserSizes))
    );
    assert_eq!(
        ::std::mem::align_of::<OptixDenoiserSizes>(),
        8usize,
        concat!("Alignment of ", stringify!(OptixDenoiserSizes))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stateSizeInBytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixDenoiserSizes),
            "::",
            stringify!(stateSizeInBytes)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).withOverlapScratchSizeInBytes) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixDenoiserSizes),
            "::",
            stringify!(withOverlapScratchSizeInBytes)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).withoutOverlapScratchSizeInBytes) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixDenoiserSizes),
            "::",
            stringify!(withoutOverlapScratchSizeInBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overlapWindowSizeInPixels) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixDenoiserSizes),
            "::",
            stringify!(overlapWindowSizeInPixels)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).computeAverageColorSizeInBytes) as usize - ptr as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixDenoiserSizes),
            "::",
            stringify!(computeAverageColorSizeInBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).computeIntensitySizeInBytes) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixDenoiserSizes),
            "::",
            stringify!(computeIntensitySizeInBytes)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).internalGuideLayerPixelSizeInBytes) as usize - ptr as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixDenoiserSizes),
            "::",
            stringify!(internalGuideLayerPixelSizeInBytes)
        )
    );
}
#[repr(u32)]
#[doc = " Ray flags passed to the device function #optixTrace().  These affect the behavior of\n traversal per invocation.\n\n \\see #optixTrace()"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum OptixRayFlags {
    #[doc = " No change from the behavior configured for the individual AS."]
    OPTIX_RAY_FLAG_NONE = 0,
    #[doc = " Disables anyhit programs for the ray.\n Overrides OPTIX_INSTANCE_FLAG_ENFORCE_ANYHIT.\n This flag is mutually exclusive with OPTIX_RAY_FLAG_ENFORCE_ANYHIT,\n OPTIX_RAY_FLAG_CULL_DISABLED_ANYHIT, OPTIX_RAY_FLAG_CULL_ENFORCED_ANYHIT."]
    OPTIX_RAY_FLAG_DISABLE_ANYHIT = 1,
    #[doc = " Forces anyhit program execution for the ray.\n Overrides OPTIX_GEOMETRY_FLAG_DISABLE_ANYHIT as well as OPTIX_INSTANCE_FLAG_DISABLE_ANYHIT.\n This flag is mutually exclusive with OPTIX_RAY_FLAG_DISABLE_ANYHIT,\n OPTIX_RAY_FLAG_CULL_DISABLED_ANYHIT, OPTIX_RAY_FLAG_CULL_ENFORCED_ANYHIT."]
    OPTIX_RAY_FLAG_ENFORCE_ANYHIT = 2,
    #[doc = " Terminates the ray after the first hit and executes\n the closesthit program of that hit."]
    OPTIX_RAY_FLAG_TERMINATE_ON_FIRST_HIT = 4,
    #[doc = " Disables closesthit programs for the ray, but still executes miss program in case of a miss."]
    OPTIX_RAY_FLAG_DISABLE_CLOSESTHIT = 8,
    #[doc = " Do not intersect triangle back faces\n (respects a possible face change due to instance flag\n OPTIX_INSTANCE_FLAG_FLIP_TRIANGLE_FACING).\n This flag is mutually exclusive with OPTIX_RAY_FLAG_CULL_FRONT_FACING_TRIANGLES."]
    OPTIX_RAY_FLAG_CULL_BACK_FACING_TRIANGLES = 16,
    #[doc = " Do not intersect triangle front faces\n (respects a possible face change due to instance flag\n OPTIX_INSTANCE_FLAG_FLIP_TRIANGLE_FACING).\n This flag is mutually exclusive with OPTIX_RAY_FLAG_CULL_BACK_FACING_TRIANGLES."]
    OPTIX_RAY_FLAG_CULL_FRONT_FACING_TRIANGLES = 32,
    #[doc = " Do not intersect geometry which disables anyhit programs\n (due to setting geometry flag OPTIX_GEOMETRY_FLAG_DISABLE_ANYHIT or\n instance flag OPTIX_INSTANCE_FLAG_DISABLE_ANYHIT).\n This flag is mutually exclusive with OPTIX_RAY_FLAG_CULL_ENFORCED_ANYHIT,\n OPTIX_RAY_FLAG_ENFORCE_ANYHIT, OPTIX_RAY_FLAG_DISABLE_ANYHIT."]
    OPTIX_RAY_FLAG_CULL_DISABLED_ANYHIT = 64,
    #[doc = " Do not intersect geometry which have an enabled anyhit program\n (due to not setting geometry flag OPTIX_GEOMETRY_FLAG_DISABLE_ANYHIT or\n setting instance flag OPTIX_INSTANCE_FLAG_ENFORCE_ANYHIT).\n This flag is mutually exclusive with OPTIX_RAY_FLAG_CULL_DISABLED_ANYHIT,\n OPTIX_RAY_FLAG_ENFORCE_ANYHIT, OPTIX_RAY_FLAG_DISABLE_ANYHIT."]
    OPTIX_RAY_FLAG_CULL_ENFORCED_ANYHIT = 128,
}
#[repr(u32)]
#[doc = " Transform\n\n OptixTransformType is used by the device function #optixGetTransformTypeFromHandle() to\n determine the type of the OptixTraversableHandle returned from\n optixGetTransformListHandle()."]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum OptixTransformType {
    #[doc = "< Not a transformation"]
    OPTIX_TRANSFORM_TYPE_NONE = 0,
    #[doc = "< \\see #OptixStaticTransform"]
    OPTIX_TRANSFORM_TYPE_STATIC_TRANSFORM = 1,
    #[doc = "< \\see #OptixMatrixMotionTransform"]
    OPTIX_TRANSFORM_TYPE_MATRIX_MOTION_TRANSFORM = 2,
    #[doc = "< \\see #OptixSRTMotionTransform"]
    OPTIX_TRANSFORM_TYPE_SRT_MOTION_TRANSFORM = 3,
    #[doc = "< \\see #OptixInstance"]
    OPTIX_TRANSFORM_TYPE_INSTANCE = 4,
}
#[repr(u32)]
#[doc = " Specifies the set of valid traversable graphs that may be\n passed to invocation of #optixTrace(). Flags may be bitwise combined."]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum OptixTraversableGraphFlags {
    #[doc = "  Used to signal that any traversable graphs is valid.\n  This flag is mutually exclusive with all other flags."]
    OPTIX_TRAVERSABLE_GRAPH_FLAG_ALLOW_ANY = 0,
    #[doc = "  Used to signal that a traversable graph of a single Geometry Acceleration\n  Structure (GAS) without any transforms is valid. This flag may be combined with\n  other flags except for OPTIX_TRAVERSABLE_GRAPH_FLAG_ALLOW_ANY."]
    OPTIX_TRAVERSABLE_GRAPH_FLAG_ALLOW_SINGLE_GAS = 1,
    #[doc = "  Used to signal that a traversable graph of a single Instance Acceleration\n  Structure (IAS) directly connected to Geometry Acceleration Structure (GAS)\n  traversables without transform traversables in between is valid.  This flag may\n  be combined with other flags except for OPTIX_TRAVERSABLE_GRAPH_FLAG_ALLOW_ANY."]
    OPTIX_TRAVERSABLE_GRAPH_FLAG_ALLOW_SINGLE_LEVEL_INSTANCING = 2,
}
#[repr(u32)]
#[doc = " Optimization levels\n\n \\see #OptixModuleCompileOptions::optLevel"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum OptixCompileOptimizationLevel {
    #[doc = " Default is to run all optimizations"]
    OPTIX_COMPILE_OPTIMIZATION_DEFAULT = 0,
    #[doc = " No optimizations"]
    OPTIX_COMPILE_OPTIMIZATION_LEVEL_0 = 9024,
    #[doc = " Some optimizations"]
    OPTIX_COMPILE_OPTIMIZATION_LEVEL_1 = 9025,
    #[doc = " Most optimizations"]
    OPTIX_COMPILE_OPTIMIZATION_LEVEL_2 = 9026,
    #[doc = " All optimizations"]
    OPTIX_COMPILE_OPTIMIZATION_LEVEL_3 = 9027,
}
#[repr(u32)]
#[doc = " Debug levels\n\n \\see #OptixModuleCompileOptions::debugLevel"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum OptixCompileDebugLevel {
    #[doc = " Default currently is minimal"]
    OPTIX_COMPILE_DEBUG_LEVEL_DEFAULT = 0,
    #[doc = " No debug information"]
    OPTIX_COMPILE_DEBUG_LEVEL_NONE = 9040,
    #[doc = " Generate information that does not impact performance.\n Note this replaces OPTIX_COMPILE_DEBUG_LEVEL_LINEINFO."]
    OPTIX_COMPILE_DEBUG_LEVEL_MINIMAL = 9041,
    #[doc = " Generate some debug information with slight performance cost"]
    OPTIX_COMPILE_DEBUG_LEVEL_MODERATE = 9043,
    #[doc = " Generate full debug information"]
    OPTIX_COMPILE_DEBUG_LEVEL_FULL = 9042,
}
#[repr(u32)]
#[doc = " Module compilation state.\n\n \\see #optixModuleGetCompilationState(), #optixModuleCreateFromPTXWithTasks()"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum OptixModuleCompileState {
    #[doc = " No OptixTask objects have started"]
    OPTIX_MODULE_COMPILE_STATE_NOT_STARTED = 9056,
    #[doc = " Started, but not all OptixTask objects have completed. No detected failures."]
    OPTIX_MODULE_COMPILE_STATE_STARTED = 9057,
    #[doc = " Not all OptixTask objects have completed, but at least one has failed."]
    OPTIX_MODULE_COMPILE_STATE_IMPENDING_FAILURE = 9058,
    #[doc = " All OptixTask objects have completed, and at least one has failed"]
    OPTIX_MODULE_COMPILE_STATE_FAILED = 9059,
    #[doc = " All OptixTask objects have completed. The OptixModule is ready to be used."]
    OPTIX_MODULE_COMPILE_STATE_COMPLETED = 9060,
}
#[doc = " Struct for specifying specializations for pipelineParams as specified in\n OptixPipelineCompileOptions::pipelineLaunchParamsVariableName.\n\n The bound values are supposed to represent a constant value in the\n pipelineParams. OptiX will attempt to locate all loads from the pipelineParams and\n correlate them to the appropriate bound value, but there are cases where OptiX cannot\n safely or reliably do this. For example if the pointer to the pipelineParams is passed\n as an argument to a non-inline function or the offset of the load to the\n pipelineParams cannot be statically determined (e.g. accessed in a loop). No module\n should rely on the value being specialized in order to work correctly.  The values in\n the pipelineParams specified on optixLaunch should match the bound value. If\n validation mode is enabled on the context, OptiX will verify that the bound values\n specified matches the values in pipelineParams specified to optixLaunch.\n\n These values are compiled in to the module as constants. Once the constants are\n inserted into the code, an optimization pass will be run that will attempt to\n propagate the consants and remove unreachable code.\n\n If caching is enabled, changes in these values will result in newly compiled modules.\n\n The pipelineParamOffset and sizeInBytes must be within the bounds of the\n pipelineParams variable. OPTIX_ERROR_INVALID_VALUE will be returned from\n optixModuleCreateFromPTX otherwise.\n\n If more than one bound value overlaps or the size of a bound value is equal to 0,\n an OPTIX_ERROR_INVALID_VALUE will be returned from optixModuleCreateFromPTX.\n\n The same set of bound values do not need to be used for all modules in a pipeline, but\n overlapping values between modules must have the same value.\n OPTIX_ERROR_INVALID_VALUE will be returned from optixPipelineCreate otherwise.\n\n \\see #OptixModuleCompileOptions"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct OptixModuleCompileBoundValueEntry {
    pub pipelineParamOffsetInBytes: usize,
    pub sizeInBytes: usize,
    pub boundValuePtr: *const ::std::os::raw::c_void,
    pub annotation: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_OptixModuleCompileBoundValueEntry() {
    const UNINIT: ::std::mem::MaybeUninit<OptixModuleCompileBoundValueEntry> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OptixModuleCompileBoundValueEntry>(),
        32usize,
        concat!("Size of: ", stringify!(OptixModuleCompileBoundValueEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<OptixModuleCompileBoundValueEntry>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(OptixModuleCompileBoundValueEntry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pipelineParamOffsetInBytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixModuleCompileBoundValueEntry),
            "::",
            stringify!(pipelineParamOffsetInBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sizeInBytes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixModuleCompileBoundValueEntry),
            "::",
            stringify!(sizeInBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).boundValuePtr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixModuleCompileBoundValueEntry),
            "::",
            stringify!(boundValuePtr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).annotation) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixModuleCompileBoundValueEntry),
            "::",
            stringify!(annotation)
        )
    );
}
impl Default for OptixModuleCompileBoundValueEntry {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[doc = " Payload type identifiers."]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum OptixPayloadTypeID {
    OPTIX_PAYLOAD_TYPE_DEFAULT = 0,
    OPTIX_PAYLOAD_TYPE_ID_0 = 1,
    OPTIX_PAYLOAD_TYPE_ID_1 = 2,
    OPTIX_PAYLOAD_TYPE_ID_2 = 4,
    OPTIX_PAYLOAD_TYPE_ID_3 = 8,
    OPTIX_PAYLOAD_TYPE_ID_4 = 16,
    OPTIX_PAYLOAD_TYPE_ID_5 = 32,
    OPTIX_PAYLOAD_TYPE_ID_6 = 64,
    OPTIX_PAYLOAD_TYPE_ID_7 = 128,
}
impl OptixPayloadSemantics {
    pub const OPTIX_PAYLOAD_SEMANTICS_CH_NONE: OptixPayloadSemantics =
        OptixPayloadSemantics::OPTIX_PAYLOAD_SEMANTICS_TRACE_CALLER_NONE;
}
impl OptixPayloadSemantics {
    pub const OPTIX_PAYLOAD_SEMANTICS_MS_NONE: OptixPayloadSemantics =
        OptixPayloadSemantics::OPTIX_PAYLOAD_SEMANTICS_TRACE_CALLER_NONE;
}
impl OptixPayloadSemantics {
    pub const OPTIX_PAYLOAD_SEMANTICS_AH_NONE: OptixPayloadSemantics =
        OptixPayloadSemantics::OPTIX_PAYLOAD_SEMANTICS_TRACE_CALLER_NONE;
}
impl OptixPayloadSemantics {
    pub const OPTIX_PAYLOAD_SEMANTICS_IS_NONE: OptixPayloadSemantics =
        OptixPayloadSemantics::OPTIX_PAYLOAD_SEMANTICS_TRACE_CALLER_NONE;
}
#[repr(u32)]
#[doc = " Semantic flags for a single payload word.\n\n Used to specify the semantics of a payload word per shader type.\n \"read\":  Shader of this type may read the payload word.\n \"write\": Shader of this type may write the payload word.\n\n \"trace_caller_write\": Shaders may consume the value of the payload word passed to optixTrace by the caller.\n \"trace_caller_read\": The caller to optixTrace may read the payload word after the call to optixTrace.\n\n Semantics can be bitwise combined.\n Combining \"read\" and \"write\" is equivalent to specifying \"read_write\".\n A payload needs to be writable by the caller or at least one shader type.\n A payload needs to be readable by the caller or at least one shader type after a being writable."]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum OptixPayloadSemantics {
    OPTIX_PAYLOAD_SEMANTICS_TRACE_CALLER_NONE = 0,
    OPTIX_PAYLOAD_SEMANTICS_TRACE_CALLER_READ = 1,
    OPTIX_PAYLOAD_SEMANTICS_TRACE_CALLER_WRITE = 2,
    OPTIX_PAYLOAD_SEMANTICS_TRACE_CALLER_READ_WRITE = 3,
    OPTIX_PAYLOAD_SEMANTICS_CH_READ = 4,
    OPTIX_PAYLOAD_SEMANTICS_CH_WRITE = 8,
    OPTIX_PAYLOAD_SEMANTICS_CH_READ_WRITE = 12,
    OPTIX_PAYLOAD_SEMANTICS_MS_READ = 16,
    OPTIX_PAYLOAD_SEMANTICS_MS_WRITE = 32,
    OPTIX_PAYLOAD_SEMANTICS_MS_READ_WRITE = 48,
    OPTIX_PAYLOAD_SEMANTICS_AH_READ = 64,
    OPTIX_PAYLOAD_SEMANTICS_AH_WRITE = 128,
    OPTIX_PAYLOAD_SEMANTICS_AH_READ_WRITE = 192,
    OPTIX_PAYLOAD_SEMANTICS_IS_READ = 256,
    OPTIX_PAYLOAD_SEMANTICS_IS_WRITE = 512,
    OPTIX_PAYLOAD_SEMANTICS_IS_READ_WRITE = 768,
}
#[doc = " Specifies a single payload type"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct OptixPayloadType {
    #[doc = " The number of 32b words the payload of this type holds"]
    pub numPayloadValues: ::std::os::raw::c_uint,
    #[doc = " Points to host array of payload word semantics, size must match numPayloadValues"]
    pub payloadSemantics: *const ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_OptixPayloadType() {
    const UNINIT: ::std::mem::MaybeUninit<OptixPayloadType> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OptixPayloadType>(),
        16usize,
        concat!("Size of: ", stringify!(OptixPayloadType))
    );
    assert_eq!(
        ::std::mem::align_of::<OptixPayloadType>(),
        8usize,
        concat!("Alignment of ", stringify!(OptixPayloadType))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numPayloadValues) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixPayloadType),
            "::",
            stringify!(numPayloadValues)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).payloadSemantics) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixPayloadType),
            "::",
            stringify!(payloadSemantics)
        )
    );
}
impl Default for OptixPayloadType {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Compilation options for module\n\n \\see #optixModuleCreateFromPTX()"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct OptixModuleCompileOptions {
    #[doc = " Maximum number of registers allowed when compiling to SASS.\n Set to 0 for no explicit limit. May vary within a pipeline."]
    pub maxRegisterCount: ::std::os::raw::c_int,
    #[doc = " Optimization level. May vary within a pipeline."]
    pub optLevel: OptixCompileOptimizationLevel,
    #[doc = " Generate debug information."]
    pub debugLevel: OptixCompileDebugLevel,
    #[doc = " Ingored if numBoundValues is set to 0"]
    pub boundValues: *const OptixModuleCompileBoundValueEntry,
    #[doc = " set to 0 if unused"]
    pub numBoundValues: ::std::os::raw::c_uint,
    #[doc = " The number of different payload types available for compilation.\n Must be zero if OptixPipelineCompileOptions::numPayloadValues is not zero."]
    pub numPayloadTypes: ::std::os::raw::c_uint,
    #[doc = " Points to host array of payload type definitions, size must match numPayloadTypes"]
    pub payloadTypes: *mut OptixPayloadType,
}
#[test]
fn bindgen_test_layout_OptixModuleCompileOptions() {
    const UNINIT: ::std::mem::MaybeUninit<OptixModuleCompileOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OptixModuleCompileOptions>(),
        40usize,
        concat!("Size of: ", stringify!(OptixModuleCompileOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<OptixModuleCompileOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(OptixModuleCompileOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxRegisterCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixModuleCompileOptions),
            "::",
            stringify!(maxRegisterCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).optLevel) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixModuleCompileOptions),
            "::",
            stringify!(optLevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).debugLevel) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixModuleCompileOptions),
            "::",
            stringify!(debugLevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).boundValues) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixModuleCompileOptions),
            "::",
            stringify!(boundValues)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numBoundValues) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixModuleCompileOptions),
            "::",
            stringify!(numBoundValues)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numPayloadTypes) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixModuleCompileOptions),
            "::",
            stringify!(numPayloadTypes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).payloadTypes) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixModuleCompileOptions),
            "::",
            stringify!(payloadTypes)
        )
    );
}
impl Default for OptixModuleCompileOptions {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[doc = " Distinguishes different kinds of program groups."]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum OptixProgramGroupKind {
    #[doc = " Program group containing a raygen (RG) program\n \\see #OptixProgramGroupSingleModule, #OptixProgramGroupDesc::raygen"]
    OPTIX_PROGRAM_GROUP_KIND_RAYGEN = 9249,
    #[doc = " Program group containing a miss (MS) program\n \\see #OptixProgramGroupSingleModule, #OptixProgramGroupDesc::miss"]
    OPTIX_PROGRAM_GROUP_KIND_MISS = 9250,
    #[doc = " Program group containing an exception (EX) program\n \\see OptixProgramGroupHitgroup, #OptixProgramGroupDesc::exception"]
    OPTIX_PROGRAM_GROUP_KIND_EXCEPTION = 9251,
    #[doc = " Program group containing an intersection (IS), any hit (AH), and/or closest hit (CH) program\n \\see #OptixProgramGroupSingleModule, #OptixProgramGroupDesc::hitgroup"]
    OPTIX_PROGRAM_GROUP_KIND_HITGROUP = 9252,
    #[doc = " Program group containing a direct (DC) or continuation (CC) callable program\n \\see OptixProgramGroupCallables, #OptixProgramGroupDesc::callables"]
    OPTIX_PROGRAM_GROUP_KIND_CALLABLES = 9253,
}
#[repr(u32)]
#[doc = " Flags for program groups"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum OptixProgramGroupFlags {
    #[doc = " Currently there are no flags"]
    OPTIX_PROGRAM_GROUP_FLAGS_NONE = 0,
}
#[doc = " Program group representing a single module.\n\n Used for raygen, miss, and exception programs. In case of raygen and exception programs, module and entry\n function name need to be valid. For miss programs, module and entry function name might both be \\c nullptr.\n\n \\see #OptixProgramGroupDesc::raygen, #OptixProgramGroupDesc::miss, #OptixProgramGroupDesc::exception"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct OptixProgramGroupSingleModule {
    #[doc = " Module holding single program."]
    pub module: OptixModule,
    #[doc = " Entry function name of the single program."]
    pub entryFunctionName: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_OptixProgramGroupSingleModule() {
    const UNINIT: ::std::mem::MaybeUninit<OptixProgramGroupSingleModule> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OptixProgramGroupSingleModule>(),
        16usize,
        concat!("Size of: ", stringify!(OptixProgramGroupSingleModule))
    );
    assert_eq!(
        ::std::mem::align_of::<OptixProgramGroupSingleModule>(),
        8usize,
        concat!("Alignment of ", stringify!(OptixProgramGroupSingleModule))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixProgramGroupSingleModule),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).entryFunctionName) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixProgramGroupSingleModule),
            "::",
            stringify!(entryFunctionName)
        )
    );
}
impl Default for OptixProgramGroupSingleModule {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Program group representing the hitgroup.\n\n For each of the three program types, module and entry function name might both be \\c nullptr.\n\n \\see #OptixProgramGroupDesc::hitgroup"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct OptixProgramGroupHitgroup {
    #[doc = " Module holding the closest hit (CH) program."]
    pub moduleCH: OptixModule,
    #[doc = " Entry function name of the closest hit (CH) program."]
    pub entryFunctionNameCH: *const ::std::os::raw::c_char,
    #[doc = " Module holding the any hit (AH) program."]
    pub moduleAH: OptixModule,
    #[doc = " Entry function name of the any hit (AH) program."]
    pub entryFunctionNameAH: *const ::std::os::raw::c_char,
    #[doc = " Module holding the intersection (Is) program."]
    pub moduleIS: OptixModule,
    #[doc = " Entry function name of the intersection (IS) program."]
    pub entryFunctionNameIS: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_OptixProgramGroupHitgroup() {
    const UNINIT: ::std::mem::MaybeUninit<OptixProgramGroupHitgroup> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OptixProgramGroupHitgroup>(),
        48usize,
        concat!("Size of: ", stringify!(OptixProgramGroupHitgroup))
    );
    assert_eq!(
        ::std::mem::align_of::<OptixProgramGroupHitgroup>(),
        8usize,
        concat!("Alignment of ", stringify!(OptixProgramGroupHitgroup))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).moduleCH) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixProgramGroupHitgroup),
            "::",
            stringify!(moduleCH)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).entryFunctionNameCH) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixProgramGroupHitgroup),
            "::",
            stringify!(entryFunctionNameCH)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).moduleAH) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixProgramGroupHitgroup),
            "::",
            stringify!(moduleAH)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).entryFunctionNameAH) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixProgramGroupHitgroup),
            "::",
            stringify!(entryFunctionNameAH)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).moduleIS) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixProgramGroupHitgroup),
            "::",
            stringify!(moduleIS)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).entryFunctionNameIS) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixProgramGroupHitgroup),
            "::",
            stringify!(entryFunctionNameIS)
        )
    );
}
impl Default for OptixProgramGroupHitgroup {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Program group representing callables.\n\n Module and entry function name need to be valid for at least one of the two callables.\n\n \\see ##OptixProgramGroupDesc::callables"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct OptixProgramGroupCallables {
    #[doc = " Module holding the direct callable (DC) program."]
    pub moduleDC: OptixModule,
    #[doc = " Entry function name of the direct callable (DC) program."]
    pub entryFunctionNameDC: *const ::std::os::raw::c_char,
    #[doc = " Module holding the continuation callable (CC) program."]
    pub moduleCC: OptixModule,
    #[doc = " Entry function name of the continuation callable (CC) program."]
    pub entryFunctionNameCC: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_OptixProgramGroupCallables() {
    const UNINIT: ::std::mem::MaybeUninit<OptixProgramGroupCallables> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OptixProgramGroupCallables>(),
        32usize,
        concat!("Size of: ", stringify!(OptixProgramGroupCallables))
    );
    assert_eq!(
        ::std::mem::align_of::<OptixProgramGroupCallables>(),
        8usize,
        concat!("Alignment of ", stringify!(OptixProgramGroupCallables))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).moduleDC) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixProgramGroupCallables),
            "::",
            stringify!(moduleDC)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).entryFunctionNameDC) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixProgramGroupCallables),
            "::",
            stringify!(entryFunctionNameDC)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).moduleCC) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixProgramGroupCallables),
            "::",
            stringify!(moduleCC)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).entryFunctionNameCC) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixProgramGroupCallables),
            "::",
            stringify!(entryFunctionNameCC)
        )
    );
}
impl Default for OptixProgramGroupCallables {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Descriptor for program groups."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OptixProgramGroupDesc {
    #[doc = " The kind of program group."]
    pub kind: OptixProgramGroupKind,
    #[doc = " See #OptixProgramGroupFlags"]
    pub flags: ::std::os::raw::c_uint,
    pub __bindgen_anon_1: OptixProgramGroupDesc__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union OptixProgramGroupDesc__bindgen_ty_1 {
    #[doc = " \\see #OPTIX_PROGRAM_GROUP_KIND_RAYGEN"]
    pub raygen: OptixProgramGroupSingleModule,
    #[doc = " \\see #OPTIX_PROGRAM_GROUP_KIND_MISS"]
    pub miss: OptixProgramGroupSingleModule,
    #[doc = " \\see #OPTIX_PROGRAM_GROUP_KIND_EXCEPTION"]
    pub exception: OptixProgramGroupSingleModule,
    #[doc = " \\see #OPTIX_PROGRAM_GROUP_KIND_CALLABLES"]
    pub callables: OptixProgramGroupCallables,
    #[doc = " \\see #OPTIX_PROGRAM_GROUP_KIND_HITGROUP"]
    pub hitgroup: OptixProgramGroupHitgroup,
}
#[test]
fn bindgen_test_layout_OptixProgramGroupDesc__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<OptixProgramGroupDesc__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OptixProgramGroupDesc__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(OptixProgramGroupDesc__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<OptixProgramGroupDesc__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(OptixProgramGroupDesc__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raygen) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixProgramGroupDesc__bindgen_ty_1),
            "::",
            stringify!(raygen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).miss) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixProgramGroupDesc__bindgen_ty_1),
            "::",
            stringify!(miss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exception) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixProgramGroupDesc__bindgen_ty_1),
            "::",
            stringify!(exception)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callables) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixProgramGroupDesc__bindgen_ty_1),
            "::",
            stringify!(callables)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hitgroup) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixProgramGroupDesc__bindgen_ty_1),
            "::",
            stringify!(hitgroup)
        )
    );
}
impl Default for OptixProgramGroupDesc__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_OptixProgramGroupDesc() {
    const UNINIT: ::std::mem::MaybeUninit<OptixProgramGroupDesc> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OptixProgramGroupDesc>(),
        56usize,
        concat!("Size of: ", stringify!(OptixProgramGroupDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<OptixProgramGroupDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(OptixProgramGroupDesc))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kind) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixProgramGroupDesc),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixProgramGroupDesc),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for OptixProgramGroupDesc {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Program group options\n\n \\see #optixProgramGroupCreate()"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct OptixProgramGroupOptions {
    #[doc = " Specifies the payload type of this program group.\n All programs in the group must support the payload type\n (Program support for a type is specified by calling\n \\see #optixSetPayloadTypes or otherwise all types specified in\n \\see #OptixModuleCompileOptions are supported).\n If a program is not available for the requested payload type,\n optixProgramGroupCreate returns OPTIX_ERROR_PAYLOAD_TYPE_MISMATCH.\n If the payloadType is left zero, a unique type is deduced.\n The payload type can be uniquely deduced if there is exactly one payload type\n for which all programs in the group are available.\n If the payload type could not be deduced uniquely\n optixProgramGroupCreate returns OPTIX_ERROR_PAYLOAD_TYPE_RESOLUTION_FAILED."]
    pub payloadType: *mut OptixPayloadType,
}
#[test]
fn bindgen_test_layout_OptixProgramGroupOptions() {
    const UNINIT: ::std::mem::MaybeUninit<OptixProgramGroupOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OptixProgramGroupOptions>(),
        8usize,
        concat!("Size of: ", stringify!(OptixProgramGroupOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<OptixProgramGroupOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(OptixProgramGroupOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).payloadType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixProgramGroupOptions),
            "::",
            stringify!(payloadType)
        )
    );
}
impl Default for OptixProgramGroupOptions {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(i32)]
#[doc = " The following values are used to indicate which exception was thrown."]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum OptixExceptionCodes {
    #[doc = " Stack overflow of the continuation stack.\n no exception details."]
    OPTIX_EXCEPTION_CODE_STACK_OVERFLOW = -1,
    #[doc = " The trace depth is exceeded.\n no exception details."]
    OPTIX_EXCEPTION_CODE_TRACE_DEPTH_EXCEEDED = -2,
    #[doc = " The traversal depth is exceeded.\n Exception details:\n     optixGetTransformListSize()\n     optixGetTransformListHandle()"]
    OPTIX_EXCEPTION_CODE_TRAVERSAL_DEPTH_EXCEEDED = -3,
    #[doc = " Traversal encountered an invalid traversable type.\n Exception details:\n     optixGetTransformListSize()\n     optixGetTransformListHandle()\n     optixGetExceptionInvalidTraversable()"]
    OPTIX_EXCEPTION_CODE_TRAVERSAL_INVALID_TRAVERSABLE = -5,
    #[doc = " The miss SBT record index is out of bounds\n A miss SBT record index is valid within the range [0, OptixShaderBindingTable::missRecordCount) (See optixLaunch)\n Exception details:\n     optixGetExceptionInvalidSbtOffset()"]
    OPTIX_EXCEPTION_CODE_TRAVERSAL_INVALID_MISS_SBT = -6,
    #[doc = "     sbt-geometry-acceleration-structure-index (See optixGetSbtGASIndex),\n     sbt-stride-from-trace-call and sbt-offset-from-trace-call (See optixTrace)\n\n sbt-index = sbt-instance-offset + (sbt-geometry-acceleration-structure-index * sbt-stride-from-trace-call) + sbt-offset-from-trace-call\n\n Exception details:\n     optixGetTransformListSize()\n     optixGetTransformListHandle()\n     optixGetExceptionInvalidSbtOffset()\n     optixGetSbtGASIndex()"]
    OPTIX_EXCEPTION_CODE_TRAVERSAL_INVALID_HIT_SBT = -7,
    #[doc = " The shader encountered an unsupported primitive type (See OptixPipelineCompileOptions::usesPrimitiveTypeFlags).\n no exception details."]
    OPTIX_EXCEPTION_CODE_UNSUPPORTED_PRIMITIVE_TYPE = -8,
    #[doc = " The shader encountered a call to optixTrace with at least\n one of the float arguments being inf or nan, or the tmin argument is negative.\n Exception details:\n     optixGetExceptionInvalidRay()"]
    OPTIX_EXCEPTION_CODE_INVALID_RAY = -9,
    #[doc = " The shader encountered a call to either optixDirectCall or optixCallableCall\n where the argument count does not match the parameter count of the callable\n program which is called.\n Exception details:\n     optixGetExceptionParameterMismatch"]
    OPTIX_EXCEPTION_CODE_CALLABLE_PARAMETER_MISMATCH = -10,
    #[doc = " The invoked builtin IS does not match the current GAS"]
    OPTIX_EXCEPTION_CODE_BUILTIN_IS_MISMATCH = -11,
    #[doc = " Tried to call a callable program using an SBT offset that is larger\n than the number of passed in callable SBT records.\n Exception details:\n     optixGetExceptionInvalidSbtOffset()"]
    OPTIX_EXCEPTION_CODE_CALLABLE_INVALID_SBT = -12,
    #[doc = " Tried to call a direct callable using an SBT offset of a record that\n was built from a program group that did not include a direct callable."]
    OPTIX_EXCEPTION_CODE_CALLABLE_NO_DC_SBT_RECORD = -13,
    #[doc = " Tried to call a continuation callable using an SBT offset of a record\n that was built from a program group that did not include a continuation callable."]
    OPTIX_EXCEPTION_CODE_CALLABLE_NO_CC_SBT_RECORD = -14,
    #[doc = " Tried to directly traverse a single gas while single gas traversable graphs are not enabled\n   (see OptixTraversableGraphFlags::OPTIX_TRAVERSABLE_GRAPH_FLAG_ALLOW_SINGLE_GAS).\n Exception details:\n     optixGetTransformListSize()\n     optixGetTransformListHandle()\n     optixGetExceptionInvalidTraversable()"]
    OPTIX_EXCEPTION_CODE_UNSUPPORTED_SINGLE_LEVEL_GAS = -15,
    #[doc = " argument passed to an optix call is\n not within an acceptable range of values."]
    OPTIX_EXCEPTION_CODE_INVALID_VALUE_ARGUMENT_0 = -16,
    #[doc = " argument passed to an optix call is\n not within an acceptable range of values."]
    OPTIX_EXCEPTION_CODE_INVALID_VALUE_ARGUMENT_1 = -17,
    #[doc = " argument passed to an optix call is\n not within an acceptable range of values."]
    OPTIX_EXCEPTION_CODE_INVALID_VALUE_ARGUMENT_2 = -18,
    #[doc = " Tried to access data on an AS without random data access support (See OptixBuildFlags)."]
    OPTIX_EXCEPTION_CODE_UNSUPPORTED_DATA_ACCESS = -32,
    #[doc = " The program payload type doesn't match the trace payload type."]
    OPTIX_EXCEPTION_CODE_PAYLOAD_TYPE_MISMATCH = -33,
}
#[repr(u32)]
#[doc = " Exception flags.\n\n \\see #OptixPipelineCompileOptions::exceptionFlags, #OptixExceptionCodes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum OptixExceptionFlags {
    #[doc = " No exception are enabled."]
    OPTIX_EXCEPTION_FLAG_NONE = 0,
    #[doc = " Enables exceptions check related to the continuation stack."]
    OPTIX_EXCEPTION_FLAG_STACK_OVERFLOW = 1,
    #[doc = " Enables exceptions check related to trace depth."]
    OPTIX_EXCEPTION_FLAG_TRACE_DEPTH = 2,
    #[doc = " Enables user exceptions via optixThrowException(). This flag must be specified for all modules in a pipeline\n if any module calls optixThrowException()."]
    OPTIX_EXCEPTION_FLAG_USER = 4,
    #[doc = " Enables various exceptions check related to traversal."]
    OPTIX_EXCEPTION_FLAG_DEBUG = 8,
}
#[doc = " Compilation options for all modules of a pipeline.\n\n Similar to #OptixModuleCompileOptions, but these options here need to be equal for all modules of a pipeline.\n\n \\see #optixModuleCreateFromPTX(), #optixPipelineCreate()"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct OptixPipelineCompileOptions {
    #[doc = " Boolean value indicating whether motion blur could be used"]
    pub usesMotionBlur: ::std::os::raw::c_int,
    #[doc = " Traversable graph bitfield. See OptixTraversableGraphFlags"]
    pub traversableGraphFlags: ::std::os::raw::c_uint,
    #[doc = " How much storage, in 32b words, to make available for the payload, [0..32]\n Must be zero if numPayloadTypes is not zero."]
    pub numPayloadValues: ::std::os::raw::c_int,
    #[doc = " How much storage, in 32b words, to make available for the attributes. The\n minimum number is 2. Values below that will automatically be changed to 2. [2..8]"]
    pub numAttributeValues: ::std::os::raw::c_int,
    #[doc = " A bitmask of OptixExceptionFlags indicating which exceptions are enabled."]
    pub exceptionFlags: ::std::os::raw::c_uint,
    #[doc = " The name of the pipeline parameter variable.  If 0, no pipeline parameter\n will be available. This will be ignored if the launch param variable was\n optimized out or was not found in the modules linked to the pipeline."]
    pub pipelineLaunchParamsVariableName: *const ::std::os::raw::c_char,
    #[doc = " Bit field enabling primitive types. See OptixPrimitiveTypeFlags.\n Setting to zero corresponds to enabling OPTIX_PRIMITIVE_TYPE_FLAGS_CUSTOM and OPTIX_PRIMITIVE_TYPE_FLAGS_TRIANGLE."]
    pub usesPrimitiveTypeFlags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_OptixPipelineCompileOptions() {
    const UNINIT: ::std::mem::MaybeUninit<OptixPipelineCompileOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OptixPipelineCompileOptions>(),
        40usize,
        concat!("Size of: ", stringify!(OptixPipelineCompileOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<OptixPipelineCompileOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(OptixPipelineCompileOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).usesMotionBlur) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixPipelineCompileOptions),
            "::",
            stringify!(usesMotionBlur)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).traversableGraphFlags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixPipelineCompileOptions),
            "::",
            stringify!(traversableGraphFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numPayloadValues) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixPipelineCompileOptions),
            "::",
            stringify!(numPayloadValues)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numAttributeValues) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixPipelineCompileOptions),
            "::",
            stringify!(numAttributeValues)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exceptionFlags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixPipelineCompileOptions),
            "::",
            stringify!(exceptionFlags)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).pipelineLaunchParamsVariableName) as usize - ptr as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixPipelineCompileOptions),
            "::",
            stringify!(pipelineLaunchParamsVariableName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).usesPrimitiveTypeFlags) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixPipelineCompileOptions),
            "::",
            stringify!(usesPrimitiveTypeFlags)
        )
    );
}
impl Default for OptixPipelineCompileOptions {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Link options for a pipeline\n\n \\see #optixPipelineCreate()"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct OptixPipelineLinkOptions {
    #[doc = " Maximum trace recursion depth. 0 means a ray generation program can be\n launched, but can't trace any rays. The maximum allowed value is 31."]
    pub maxTraceDepth: ::std::os::raw::c_uint,
    #[doc = " Generate debug information."]
    pub debugLevel: OptixCompileDebugLevel,
}
#[test]
fn bindgen_test_layout_OptixPipelineLinkOptions() {
    const UNINIT: ::std::mem::MaybeUninit<OptixPipelineLinkOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OptixPipelineLinkOptions>(),
        8usize,
        concat!("Size of: ", stringify!(OptixPipelineLinkOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<OptixPipelineLinkOptions>(),
        4usize,
        concat!("Alignment of ", stringify!(OptixPipelineLinkOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxTraceDepth) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixPipelineLinkOptions),
            "::",
            stringify!(maxTraceDepth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).debugLevel) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixPipelineLinkOptions),
            "::",
            stringify!(debugLevel)
        )
    );
}
impl Default for OptixPipelineLinkOptions {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Describes the shader binding table (SBT)\n\n \\see #optixLaunch()"]
#[repr(C)]
pub struct OptixShaderBindingTable {
    #[doc = " Device address of the SBT record of the ray gen program to start launch at. The address must be a multiple of\n OPTIX_SBT_RECORD_ALIGNMENT."]
    pub raygenRecord: CUdeviceptr,
    #[doc = " Device address of the SBT record of the exception program. The address must be a multiple of\n OPTIX_SBT_RECORD_ALIGNMENT."]
    pub exceptionRecord: CUdeviceptr,
    #[doc = " Arrays of SBT records for miss programs. The base address and the stride must be a multiple of\n OPTIX_SBT_RECORD_ALIGNMENT.\n @{"]
    pub missRecordBase: CUdeviceptr,
    pub missRecordStrideInBytes: ::std::os::raw::c_uint,
    pub missRecordCount: ::std::os::raw::c_uint,
    #[doc = " Arrays of SBT records for hit groups. The base address and the stride must be a multiple of\n OPTIX_SBT_RECORD_ALIGNMENT.\n @{"]
    pub hitgroupRecordBase: CUdeviceptr,
    pub hitgroupRecordStrideInBytes: ::std::os::raw::c_uint,
    pub hitgroupRecordCount: ::std::os::raw::c_uint,
    #[doc = " Arrays of SBT records for callable programs. If the base address is not null, the stride and count must not be\n zero. If the base address is null, then the count needs to zero. The base address and the stride must be a\n multiple of OPTIX_SBT_RECORD_ALIGNMENT.\n @{"]
    pub callablesRecordBase: CUdeviceptr,
    pub callablesRecordStrideInBytes: ::std::os::raw::c_uint,
    pub callablesRecordCount: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_OptixShaderBindingTable() {
    const UNINIT: ::std::mem::MaybeUninit<OptixShaderBindingTable> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OptixShaderBindingTable>(),
        64usize,
        concat!("Size of: ", stringify!(OptixShaderBindingTable))
    );
    assert_eq!(
        ::std::mem::align_of::<OptixShaderBindingTable>(),
        8usize,
        concat!("Alignment of ", stringify!(OptixShaderBindingTable))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raygenRecord) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixShaderBindingTable),
            "::",
            stringify!(raygenRecord)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exceptionRecord) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixShaderBindingTable),
            "::",
            stringify!(exceptionRecord)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).missRecordBase) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixShaderBindingTable),
            "::",
            stringify!(missRecordBase)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).missRecordStrideInBytes) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixShaderBindingTable),
            "::",
            stringify!(missRecordStrideInBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).missRecordCount) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixShaderBindingTable),
            "::",
            stringify!(missRecordCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hitgroupRecordBase) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixShaderBindingTable),
            "::",
            stringify!(hitgroupRecordBase)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hitgroupRecordStrideInBytes) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixShaderBindingTable),
            "::",
            stringify!(hitgroupRecordStrideInBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hitgroupRecordCount) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixShaderBindingTable),
            "::",
            stringify!(hitgroupRecordCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callablesRecordBase) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixShaderBindingTable),
            "::",
            stringify!(callablesRecordBase)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).callablesRecordStrideInBytes) as usize - ptr as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixShaderBindingTable),
            "::",
            stringify!(callablesRecordStrideInBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callablesRecordCount) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixShaderBindingTable),
            "::",
            stringify!(callablesRecordCount)
        )
    );
}
impl Default for OptixShaderBindingTable {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Describes the stack size requirements of a program group.\n\n \\see optixProgramGroupGetStackSize()"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct OptixStackSizes {
    #[doc = " Continuation stack size of RG programs in bytes"]
    pub cssRG: ::std::os::raw::c_uint,
    #[doc = " Continuation stack size of MS programs in bytes"]
    pub cssMS: ::std::os::raw::c_uint,
    #[doc = " Continuation stack size of CH programs in bytes"]
    pub cssCH: ::std::os::raw::c_uint,
    #[doc = " Continuation stack size of AH programs in bytes"]
    pub cssAH: ::std::os::raw::c_uint,
    #[doc = " Continuation stack size of IS programs in bytes"]
    pub cssIS: ::std::os::raw::c_uint,
    #[doc = " Continuation stack size of CC programs in bytes"]
    pub cssCC: ::std::os::raw::c_uint,
    #[doc = " Direct stack size of DC programs in bytes"]
    pub dssDC: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_OptixStackSizes() {
    const UNINIT: ::std::mem::MaybeUninit<OptixStackSizes> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OptixStackSizes>(),
        28usize,
        concat!("Size of: ", stringify!(OptixStackSizes))
    );
    assert_eq!(
        ::std::mem::align_of::<OptixStackSizes>(),
        4usize,
        concat!("Alignment of ", stringify!(OptixStackSizes))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cssRG) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixStackSizes),
            "::",
            stringify!(cssRG)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cssMS) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixStackSizes),
            "::",
            stringify!(cssMS)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cssCH) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixStackSizes),
            "::",
            stringify!(cssCH)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cssAH) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixStackSizes),
            "::",
            stringify!(cssAH)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cssIS) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixStackSizes),
            "::",
            stringify!(cssIS)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cssCC) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixStackSizes),
            "::",
            stringify!(cssCC)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dssDC) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixStackSizes),
            "::",
            stringify!(dssDC)
        )
    );
}
#[repr(u32)]
#[doc = " Options that can be passed to \\c optixQueryFunctionTable()"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum OptixQueryFunctionTableOptions {
    #[doc = " Placeholder (there are no options yet)"]
    OPTIX_QUERY_FUNCTION_TABLE_OPTION_DUMMY = 0,
}
#[doc = " Type of the function \\c optixQueryFunctionTable()"]
pub type OptixQueryFunctionTable_t = ::std::option::Option<
    unsafe extern "C" fn(
        abiId: ::std::os::raw::c_int,
        numOptions: ::std::os::raw::c_uint,
        arg1: *mut OptixQueryFunctionTableOptions,
        arg2: *mut *const ::std::os::raw::c_void,
        functionTable: *mut ::std::os::raw::c_void,
        sizeOfTable: usize,
    ) -> OptixResult,
>;
#[doc = " Specifies the options for retrieving an intersection program for a built-in primitive type.\n The primitive type must not be OPTIX_PRIMITIVE_TYPE_CUSTOM.\n\n \\see #optixBuiltinISModuleGet()"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct OptixBuiltinISOptions {
    pub builtinISModuleType: OptixPrimitiveType,
    #[doc = " Boolean value indicating whether vertex motion blur is used (but not motion transform blur)."]
    pub usesMotionBlur: ::std::os::raw::c_int,
    #[doc = " Build flags, see OptixBuildFlags."]
    pub buildFlags: ::std::os::raw::c_uint,
    #[doc = " End cap properties of curves, see OptixCurveEndcapFlags, 0 for non-curve types."]
    pub curveEndcapFlags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_OptixBuiltinISOptions() {
    const UNINIT: ::std::mem::MaybeUninit<OptixBuiltinISOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OptixBuiltinISOptions>(),
        16usize,
        concat!("Size of: ", stringify!(OptixBuiltinISOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<OptixBuiltinISOptions>(),
        4usize,
        concat!("Alignment of ", stringify!(OptixBuiltinISOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).builtinISModuleType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuiltinISOptions),
            "::",
            stringify!(builtinISModuleType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).usesMotionBlur) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuiltinISOptions),
            "::",
            stringify!(usesMotionBlur)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buildFlags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuiltinISOptions),
            "::",
            stringify!(buildFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).curveEndcapFlags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixBuiltinISOptions),
            "::",
            stringify!(curveEndcapFlags)
        )
    );
}
impl Default for OptixBuiltinISOptions {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " The function table containing all API functions.\n\n See #optixInit() and #optixInitWithHandle()."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct OptixFunctionTable {
    #[doc = " See ::optixGetErrorName()."]
    pub optixGetErrorName: ::std::option::Option<
        unsafe extern "C" fn(result: OptixResult) -> *const ::std::os::raw::c_char,
    >,
    #[doc = " See ::optixGetErrorString()."]
    pub optixGetErrorString: ::std::option::Option<
        unsafe extern "C" fn(result: OptixResult) -> *const ::std::os::raw::c_char,
    >,
    #[doc = " See ::optixDeviceContextCreate()."]
    pub optixDeviceContextCreate: ::std::option::Option<
        unsafe extern "C" fn(
            fromContext: CUcontext,
            options: *const OptixDeviceContextOptions,
            context: *mut OptixDeviceContext,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixDeviceContextDestroy()."]
    pub optixDeviceContextDestroy:
        ::std::option::Option<unsafe extern "C" fn(context: OptixDeviceContext) -> OptixResult>,
    #[doc = " See ::optixDeviceContextGetProperty()."]
    pub optixDeviceContextGetProperty: ::std::option::Option<
        unsafe extern "C" fn(
            context: OptixDeviceContext,
            property: OptixDeviceProperty,
            value: *mut ::std::os::raw::c_void,
            sizeInBytes: usize,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixDeviceContextSetLogCallback()."]
    pub optixDeviceContextSetLogCallback: ::std::option::Option<
        unsafe extern "C" fn(
            context: OptixDeviceContext,
            callbackFunction: OptixLogCallback,
            callbackData: *mut ::std::os::raw::c_void,
            callbackLevel: ::std::os::raw::c_uint,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixDeviceContextSetCacheEnabled()."]
    pub optixDeviceContextSetCacheEnabled: ::std::option::Option<
        unsafe extern "C" fn(
            context: OptixDeviceContext,
            enabled: ::std::os::raw::c_int,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixDeviceContextSetCacheLocation()."]
    pub optixDeviceContextSetCacheLocation: ::std::option::Option<
        unsafe extern "C" fn(
            context: OptixDeviceContext,
            location: *const ::std::os::raw::c_char,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixDeviceContextSetCacheDatabaseSizes()."]
    pub optixDeviceContextSetCacheDatabaseSizes: ::std::option::Option<
        unsafe extern "C" fn(
            context: OptixDeviceContext,
            lowWaterMark: usize,
            highWaterMark: usize,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixDeviceContextGetCacheEnabled()."]
    pub optixDeviceContextGetCacheEnabled: ::std::option::Option<
        unsafe extern "C" fn(
            context: OptixDeviceContext,
            enabled: *mut ::std::os::raw::c_int,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixDeviceContextGetCacheLocation()."]
    pub optixDeviceContextGetCacheLocation: ::std::option::Option<
        unsafe extern "C" fn(
            context: OptixDeviceContext,
            location: *mut ::std::os::raw::c_char,
            locationSize: usize,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixDeviceContextGetCacheDatabaseSizes()."]
    pub optixDeviceContextGetCacheDatabaseSizes: ::std::option::Option<
        unsafe extern "C" fn(
            context: OptixDeviceContext,
            lowWaterMark: *mut usize,
            highWaterMark: *mut usize,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixModuleCreateFromPTX()."]
    pub optixModuleCreateFromPTX: ::std::option::Option<
        unsafe extern "C" fn(
            context: OptixDeviceContext,
            moduleCompileOptions: *const OptixModuleCompileOptions,
            pipelineCompileOptions: *const OptixPipelineCompileOptions,
            PTX: *const ::std::os::raw::c_char,
            PTXsize: usize,
            logString: *mut ::std::os::raw::c_char,
            logStringSize: *mut usize,
            module: *mut OptixModule,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixModuleCreateFromPTXWithTasks()."]
    pub optixModuleCreateFromPTXWithTasks: ::std::option::Option<
        unsafe extern "C" fn(
            context: OptixDeviceContext,
            moduleCompileOptions: *const OptixModuleCompileOptions,
            pipelineCompileOptions: *const OptixPipelineCompileOptions,
            PTX: *const ::std::os::raw::c_char,
            PTXsize: usize,
            logString: *mut ::std::os::raw::c_char,
            logStringSize: *mut usize,
            module: *mut OptixModule,
            firstTask: *mut OptixTask,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixModuleGetCompilationState()."]
    pub optixModuleGetCompilationState: ::std::option::Option<
        unsafe extern "C" fn(
            module: OptixModule,
            state: *mut OptixModuleCompileState,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixModuleDestroy()."]
    pub optixModuleDestroy:
        ::std::option::Option<unsafe extern "C" fn(module: OptixModule) -> OptixResult>,
    #[doc = " See ::optixBuiltinISModuleGet()."]
    pub optixBuiltinISModuleGet: ::std::option::Option<
        unsafe extern "C" fn(
            context: OptixDeviceContext,
            moduleCompileOptions: *const OptixModuleCompileOptions,
            pipelineCompileOptions: *const OptixPipelineCompileOptions,
            builtinISOptions: *const OptixBuiltinISOptions,
            builtinModule: *mut OptixModule,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixTaskExecute()."]
    pub optixTaskExecute: ::std::option::Option<
        unsafe extern "C" fn(
            task: OptixTask,
            additionalTasks: *mut OptixTask,
            maxNumAdditionalTasks: ::std::os::raw::c_uint,
            numAdditionalTasksCreated: *mut ::std::os::raw::c_uint,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixProgramGroupCreate()."]
    pub optixProgramGroupCreate: ::std::option::Option<
        unsafe extern "C" fn(
            context: OptixDeviceContext,
            programDescriptions: *const OptixProgramGroupDesc,
            numProgramGroups: ::std::os::raw::c_uint,
            options: *const OptixProgramGroupOptions,
            logString: *mut ::std::os::raw::c_char,
            logStringSize: *mut usize,
            programGroups: *mut OptixProgramGroup,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixProgramGroupDestroy()."]
    pub optixProgramGroupDestroy:
        ::std::option::Option<unsafe extern "C" fn(programGroup: OptixProgramGroup) -> OptixResult>,
    #[doc = " See ::optixProgramGroupGetStackSize()."]
    pub optixProgramGroupGetStackSize: ::std::option::Option<
        unsafe extern "C" fn(
            programGroup: OptixProgramGroup,
            stackSizes: *mut OptixStackSizes,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixPipelineCreate()."]
    pub optixPipelineCreate: ::std::option::Option<
        unsafe extern "C" fn(
            context: OptixDeviceContext,
            pipelineCompileOptions: *const OptixPipelineCompileOptions,
            pipelineLinkOptions: *const OptixPipelineLinkOptions,
            programGroups: *const OptixProgramGroup,
            numProgramGroups: ::std::os::raw::c_uint,
            logString: *mut ::std::os::raw::c_char,
            logStringSize: *mut usize,
            pipeline: *mut OptixPipeline,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixPipelineDestroy()."]
    pub optixPipelineDestroy:
        ::std::option::Option<unsafe extern "C" fn(pipeline: OptixPipeline) -> OptixResult>,
    #[doc = " See ::optixPipelineSetStackSize()."]
    pub optixPipelineSetStackSize: ::std::option::Option<
        unsafe extern "C" fn(
            pipeline: OptixPipeline,
            directCallableStackSizeFromTraversal: ::std::os::raw::c_uint,
            directCallableStackSizeFromState: ::std::os::raw::c_uint,
            continuationStackSize: ::std::os::raw::c_uint,
            maxTraversableGraphDepth: ::std::os::raw::c_uint,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixAccelComputeMemoryUsage()."]
    pub optixAccelComputeMemoryUsage: ::std::option::Option<
        unsafe extern "C" fn(
            context: OptixDeviceContext,
            accelOptions: *const OptixAccelBuildOptions,
            buildInputs: *const OptixBuildInput,
            numBuildInputs: ::std::os::raw::c_uint,
            bufferSizes: *mut OptixAccelBufferSizes,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixAccelBuild()."]
    pub optixAccelBuild: ::std::option::Option<
        unsafe extern "C" fn(
            context: OptixDeviceContext,
            stream: CUstream,
            accelOptions: *const OptixAccelBuildOptions,
            buildInputs: *const OptixBuildInput,
            numBuildInputs: ::std::os::raw::c_uint,
            tempBuffer: CUdeviceptr,
            tempBufferSizeInBytes: usize,
            outputBuffer: CUdeviceptr,
            outputBufferSizeInBytes: usize,
            outputHandle: *mut OptixTraversableHandle,
            emittedProperties: *const OptixAccelEmitDesc,
            numEmittedProperties: ::std::os::raw::c_uint,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixAccelGetRelocationInfo()."]
    pub optixAccelGetRelocationInfo: ::std::option::Option<
        unsafe extern "C" fn(
            context: OptixDeviceContext,
            handle: OptixTraversableHandle,
            info: *mut OptixAccelRelocationInfo,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixAccelCheckRelocationCompatibility()."]
    pub optixAccelCheckRelocationCompatibility: ::std::option::Option<
        unsafe extern "C" fn(
            context: OptixDeviceContext,
            info: *const OptixAccelRelocationInfo,
            compatible: *mut ::std::os::raw::c_int,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixAccelRelocate()."]
    pub optixAccelRelocate: ::std::option::Option<
        unsafe extern "C" fn(
            context: OptixDeviceContext,
            stream: CUstream,
            info: *const OptixAccelRelocationInfo,
            instanceTraversableHandles: CUdeviceptr,
            numInstanceTraversableHandles: usize,
            targetAccel: CUdeviceptr,
            targetAccelSizeInBytes: usize,
            targetHandle: *mut OptixTraversableHandle,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixAccelCompact()."]
    pub optixAccelCompact: ::std::option::Option<
        unsafe extern "C" fn(
            context: OptixDeviceContext,
            stream: CUstream,
            inputHandle: OptixTraversableHandle,
            outputBuffer: CUdeviceptr,
            outputBufferSizeInBytes: usize,
            outputHandle: *mut OptixTraversableHandle,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixConvertPointerToTraversableHandle()."]
    pub optixConvertPointerToTraversableHandle: ::std::option::Option<
        unsafe extern "C" fn(
            onDevice: OptixDeviceContext,
            pointer: CUdeviceptr,
            traversableType: OptixTraversableType,
            traversableHandle: *mut OptixTraversableHandle,
        ) -> OptixResult,
    >,
    pub reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    #[doc = " See ::optixConvertPointerToTraversableHandle()."]
    pub optixSbtRecordPackHeader: ::std::option::Option<
        unsafe extern "C" fn(
            programGroup: OptixProgramGroup,
            sbtRecordHeaderHostPointer: *mut ::std::os::raw::c_void,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixConvertPointerToTraversableHandle()."]
    pub optixLaunch: ::std::option::Option<
        unsafe extern "C" fn(
            pipeline: OptixPipeline,
            stream: CUstream,
            pipelineParams: CUdeviceptr,
            pipelineParamsSize: usize,
            sbt: *const OptixShaderBindingTable,
            width: ::std::os::raw::c_uint,
            height: ::std::os::raw::c_uint,
            depth: ::std::os::raw::c_uint,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixDenoiserCreate()."]
    pub optixDenoiserCreate: ::std::option::Option<
        unsafe extern "C" fn(
            context: OptixDeviceContext,
            modelKind: OptixDenoiserModelKind,
            options: *const OptixDenoiserOptions,
            returnHandle: *mut OptixDenoiser,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixDenoiserDestroy()."]
    pub optixDenoiserDestroy:
        ::std::option::Option<unsafe extern "C" fn(handle: OptixDenoiser) -> OptixResult>,
    #[doc = " See ::optixDenoiserComputeMemoryResources()."]
    pub optixDenoiserComputeMemoryResources: ::std::option::Option<
        unsafe extern "C" fn(
            handle: OptixDenoiser,
            maximumInputWidth: ::std::os::raw::c_uint,
            maximumInputHeight: ::std::os::raw::c_uint,
            returnSizes: *mut OptixDenoiserSizes,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixDenoiserSetup()."]
    pub optixDenoiserSetup: ::std::option::Option<
        unsafe extern "C" fn(
            denoiser: OptixDenoiser,
            stream: CUstream,
            inputWidth: ::std::os::raw::c_uint,
            inputHeight: ::std::os::raw::c_uint,
            state: CUdeviceptr,
            stateSizeInBytes: usize,
            scratch: CUdeviceptr,
            scratchSizeInBytes: usize,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixDenoiserInvoke()."]
    pub optixDenoiserInvoke: ::std::option::Option<
        unsafe extern "C" fn(
            denoiser: OptixDenoiser,
            stream: CUstream,
            params: *const OptixDenoiserParams,
            denoiserState: CUdeviceptr,
            denoiserStateSizeInBytes: usize,
            guideLayer: *const OptixDenoiserGuideLayer,
            layers: *const OptixDenoiserLayer,
            numLayers: ::std::os::raw::c_uint,
            inputOffsetX: ::std::os::raw::c_uint,
            inputOffsetY: ::std::os::raw::c_uint,
            scratch: CUdeviceptr,
            scratchSizeInBytes: usize,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixDenoiserComputeIntensity()."]
    pub optixDenoiserComputeIntensity: ::std::option::Option<
        unsafe extern "C" fn(
            handle: OptixDenoiser,
            stream: CUstream,
            inputImage: *const OptixImage2D,
            outputIntensity: CUdeviceptr,
            scratch: CUdeviceptr,
            scratchSizeInBytes: usize,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixDenoiserComputeAverageColor()."]
    pub optixDenoiserComputeAverageColor: ::std::option::Option<
        unsafe extern "C" fn(
            handle: OptixDenoiser,
            stream: CUstream,
            inputImage: *const OptixImage2D,
            outputAverageColor: CUdeviceptr,
            scratch: CUdeviceptr,
            scratchSizeInBytes: usize,
        ) -> OptixResult,
    >,
    #[doc = " See ::optixDenoiserCreateWithUserModel()."]
    pub optixDenoiserCreateWithUserModel: ::std::option::Option<
        unsafe extern "C" fn(
            context: OptixDeviceContext,
            data: *const ::std::os::raw::c_void,
            dataSizeInBytes: usize,
            returnHandle: *mut OptixDenoiser,
        ) -> OptixResult,
    >,
}
#[test]
fn bindgen_test_layout_OptixFunctionTable() {
    const UNINIT: ::std::mem::MaybeUninit<OptixFunctionTable> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OptixFunctionTable>(),
        344usize,
        concat!("Size of: ", stringify!(OptixFunctionTable))
    );
    assert_eq!(
        ::std::mem::align_of::<OptixFunctionTable>(),
        8usize,
        concat!("Alignment of ", stringify!(OptixFunctionTable))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).optixGetErrorName) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixFunctionTable),
            "::",
            stringify!(optixGetErrorName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).optixGetErrorString) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixFunctionTable),
            "::",
            stringify!(optixGetErrorString)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).optixDeviceContextCreate) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixFunctionTable),
            "::",
            stringify!(optixDeviceContextCreate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).optixDeviceContextDestroy) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixFunctionTable),
            "::",
            stringify!(optixDeviceContextDestroy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).optixDeviceContextGetProperty) as usize - ptr as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixFunctionTable),
            "::",
            stringify!(optixDeviceContextGetProperty)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).optixDeviceContextSetLogCallback) as usize - ptr as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixFunctionTable),
            "::",
            stringify!(optixDeviceContextSetLogCallback)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).optixDeviceContextSetCacheEnabled) as usize - ptr as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixFunctionTable),
            "::",
            stringify!(optixDeviceContextSetCacheEnabled)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).optixDeviceContextSetCacheLocation) as usize - ptr as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixFunctionTable),
            "::",
            stringify!(optixDeviceContextSetCacheLocation)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).optixDeviceContextSetCacheDatabaseSizes) as usize
                - ptr as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixFunctionTable),
            "::",
            stringify!(optixDeviceContextSetCacheDatabaseSizes)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).optixDeviceContextGetCacheEnabled) as usize - ptr as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixFunctionTable),
            "::",
            stringify!(optixDeviceContextGetCacheEnabled)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).optixDeviceContextGetCacheLocation) as usize - ptr as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixFunctionTable),
            "::",
            stringify!(optixDeviceContextGetCacheLocation)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).optixDeviceContextGetCacheDatabaseSizes) as usize
                - ptr as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixFunctionTable),
            "::",
            stringify!(optixDeviceContextGetCacheDatabaseSizes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).optixModuleCreateFromPTX) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixFunctionTable),
            "::",
            stringify!(optixModuleCreateFromPTX)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).optixModuleCreateFromPTXWithTasks) as usize - ptr as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixFunctionTable),
            "::",
            stringify!(optixModuleCreateFromPTXWithTasks)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).optixModuleGetCompilationState) as usize - ptr as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixFunctionTable),
            "::",
            stringify!(optixModuleGetCompilationState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).optixModuleDestroy) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixFunctionTable),
            "::",
            stringify!(optixModuleDestroy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).optixBuiltinISModuleGet) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixFunctionTable),
            "::",
            stringify!(optixBuiltinISModuleGet)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).optixTaskExecute) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixFunctionTable),
            "::",
            stringify!(optixTaskExecute)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).optixProgramGroupCreate) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixFunctionTable),
            "::",
            stringify!(optixProgramGroupCreate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).optixProgramGroupDestroy) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixFunctionTable),
            "::",
            stringify!(optixProgramGroupDestroy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).optixProgramGroupGetStackSize) as usize - ptr as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixFunctionTable),
            "::",
            stringify!(optixProgramGroupGetStackSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).optixPipelineCreate) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixFunctionTable),
            "::",
            stringify!(optixPipelineCreate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).optixPipelineDestroy) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixFunctionTable),
            "::",
            stringify!(optixPipelineDestroy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).optixPipelineSetStackSize) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixFunctionTable),
            "::",
            stringify!(optixPipelineSetStackSize)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).optixAccelComputeMemoryUsage) as usize - ptr as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixFunctionTable),
            "::",
            stringify!(optixAccelComputeMemoryUsage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).optixAccelBuild) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixFunctionTable),
            "::",
            stringify!(optixAccelBuild)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).optixAccelGetRelocationInfo) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixFunctionTable),
            "::",
            stringify!(optixAccelGetRelocationInfo)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).optixAccelCheckRelocationCompatibility) as usize
                - ptr as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixFunctionTable),
            "::",
            stringify!(optixAccelCheckRelocationCompatibility)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).optixAccelRelocate) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixFunctionTable),
            "::",
            stringify!(optixAccelRelocate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).optixAccelCompact) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixFunctionTable),
            "::",
            stringify!(optixAccelCompact)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).optixConvertPointerToTraversableHandle) as usize
                - ptr as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixFunctionTable),
            "::",
            stringify!(optixConvertPointerToTraversableHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixFunctionTable),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixFunctionTable),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).optixSbtRecordPackHeader) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixFunctionTable),
            "::",
            stringify!(optixSbtRecordPackHeader)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).optixLaunch) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixFunctionTable),
            "::",
            stringify!(optixLaunch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).optixDenoiserCreate) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixFunctionTable),
            "::",
            stringify!(optixDenoiserCreate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).optixDenoiserDestroy) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixFunctionTable),
            "::",
            stringify!(optixDenoiserDestroy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).optixDenoiserComputeMemoryResources) as usize - ptr as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixFunctionTable),
            "::",
            stringify!(optixDenoiserComputeMemoryResources)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).optixDenoiserSetup) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixFunctionTable),
            "::",
            stringify!(optixDenoiserSetup)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).optixDenoiserInvoke) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixFunctionTable),
            "::",
            stringify!(optixDenoiserInvoke)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).optixDenoiserComputeIntensity) as usize - ptr as usize
        },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixFunctionTable),
            "::",
            stringify!(optixDenoiserComputeIntensity)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).optixDenoiserComputeAverageColor) as usize - ptr as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixFunctionTable),
            "::",
            stringify!(optixDenoiserComputeAverageColor)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).optixDenoiserCreateWithUserModel) as usize - ptr as usize
        },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(OptixFunctionTable),
            "::",
            stringify!(optixDenoiserCreateWithUserModel)
        )
    );
}
